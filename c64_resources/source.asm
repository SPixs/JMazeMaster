;
; **** ZP FIELDS **** 
;
f00 = $00
f01 = $01
f02 = $02
f05 = $05
f08 = $08
f0A = $0A
f0B = $0B
f0C = $0C
f0D = $0D
f0E = $0E
f0F = $0F
f10 = $10
f11 = $11
f12 = $12
f14 = $14
f15 = $15
f17 = $17
f18 = $18
f1B = $1B
f1C = $1C
f1D = $1D
f1E = $1E
f1F = $1F
f22 = $22
f24 = $24
f25 = $25
f26 = $26
f29 = $29
f2A = $2A
f31 = $31
f32 = $32
f36 = $36
f38 = $38
f3C = $3C
f40 = $40
f41 = $41
f42 = $42
f43 = $43
f44 = $44
f45 = $45
f48 = $48
f49 = $49
f4A = $4A
f4E = $4E
f50 = $50
f51 = $51
f52 = $52
f53 = $53
f54 = $54
f55 = $55
f56 = $56
f57 = $57
f58 = $58
f59 = $59
f5A = $5A
f5F = $5F
f60 = $60
f61 = $61
f64 = $64
f65 = $65
f66 = $66
f68 = $68
f6A = $6A
f84 = $84
f95 = $95
f9F = $9F
fA0 = $A0
fA3 = $A3
fA8 = $A8
fA9 = $A9
fAA = $AA
fB5 = $B5
fD0 = $D0
fD5 = $D5
fDB = $DB
fE6 = $E6
fFF = $FF
;
; **** ZP ABSOLUTE ADRESSES **** 
;
a00 = $00
a01 = $01
a02 = $02
a03 = $03
a04 = $04
a05 = $05
a06 = $06
a07 = $07
a08 = $08
a09 = $09
a0A = $0A
a0B = $0B
a0C = $0C
a0D = $0D
a0E = $0E
a0F = $0F
a10 = $10
a11 = $11
a12 = $12
a13 = $13
a14 = $14
a15 = $15
a16 = $16
a17 = $17
a18 = $18
a19 = $19
a1B = $1B
a1C = $1C
a1D = $1D
a1E = $1E
a1F = $1F
a20 = $20
a21 = $21
a22 = $22
a24 = $24
a25 = $25
a26 = $26
a27 = $27
a28 = $28
a29 = $29
a2B = $2B
a2C = $2C
a35 = $35
a36 = $36
a39 = $39
a3A = $3A
a3B = $3B
a3C = $3C
a3D = $3D
a3E = $3E
a40 = $40
a41 = $41
a44 = $44
a45 = $45
a46 = $46
a47 = $47
a48 = $48
a49 = $49
a4A = $4A
a4B = $4B
a4C = $4C
a4D = $4D
a4E = $4E
a4F = $4F
a50 = $50
a51 = $51
a52 = $52
a54 = $54
a55 = $55
a56 = $56
a57 = $57
a5A = $5A
a60 = $60
a62 = $62
a63 = $63
a64 = $64
a65 = $65
a66 = $66
a67 = $67
a6A = $6A
a6E = $6E
a6F = $6F
a73 = $73
a74 = $74
a75 = $75
a76 = $76
a7A = $7A
a80 = $80
a81 = $81
a82 = $82
a83 = $83
a84 = $84
a85 = $85
a86 = $86
a87 = $87
a88 = $88
a89 = $89
a90 = $90
a91 = $91
a92 = $92
a94 = $94
a95 = $95
a96 = $96
a99 = $99
aA0 = $A0
aA1 = $A1
aA4 = $A4
aA5 = $A5
aA8 = $A8
aB4 = $B4
aB5 = $B5
aB9 = $B9
aD0 = $D0
aE8 = $E8
aF0 = $F0
aF2 = $F2
aF5 = $F5
aFB = $FB
aFC = $FC
aFD = $FD
aFE = $FE
aFF = $FF
;
; **** ZP POINTERS **** 
;
p00 = $00
p01 = $01
p02 = $02
p03 = $03
p04 = $04
p05 = $05
p06 = $06
p07 = $07
p08 = $08
p09 = $09
p0A = $0A
p0C = $0C
p0E = $0E
p0F = $0F
p10 = $10
p11 = $11
p12 = $12
p13 = $13
p14 = $14
p18 = $18
p19 = $19
p1D = $1D
p20 = $20
p21 = $21
p22 = $22
p24 = $24
p27 = $27
p28 = $28
p2A = $2A
p2C = $2C
p31 = $31
p34 = $34
p3B = $3B
p40 = $40
p41 = $41
p42 = $42
p44 = $44
p48 = $48
p49 = $49
p4B = $4B
p50 = $50
p51 = $51
p52 = $52
p54 = $54
p55 = $55
p56 = $56
p58 = $58
p59 = $59
p5A = $5A
p60 = $60
p61 = $61
p64 = $64
p66 = $66
p69 = $69
p6A = $6A
p76 = $76
p78 = $78
p80 = $80
p81 = $81
p85 = $85
p88 = $88
p90 = $90
p91 = $91
p95 = $95
pA0 = $A0
pA5 = $A5
pC0 = $C0
pC1 = $C1
pC2 = $C2
pDC = $DC
pE1 = $E1
pE8 = $E8
pF0 = $F0
pF5 = $F5
pFB = $FB
pFC = $FC
pFD = $FD
pFF = $FF
;
; **** FIELDS **** 
;
f0002 = $0002
f0003 = $0003
f0006 = $0006
f0007 = $0007
f000E = $000E
f0030 = $0030
f003F = $003F
f0055 = $0055
f0057 = $0057
f005C = $005C
f00A0 = $00A0
f00B5 = $00B5
f00D5 = $00D5
f00F0 = $00F0
f00FF = $00FF
f0108 = $0108
f0117 = $0117
f0141 = $0141
f01FF = $01FF
f0205 = $0205
f02B5 = $02B5
f0300 = $0300
f0411 = $0411
f0549 = $0549
f0666 = $0666
f06B5 = $06B5
f06FF = $06FF
f0703 = $0703
f09B5 = $09B5
f0A0B = $0A0B
f0A0C = $0A0C
f0A16 = $0A16
f0A1D = $0A1D
f0A20 = $0A20
f0A24 = $0A24
f0B00 = $0B00
f0B11 = $0B11
f0B16 = $0B16
f0B24 = $0B24
f0C0A = $0C0A
f0C12 = $0C12
f0C1C = $0C1C
f0CB5 = $0CB5
f0CFF = $0CFF
f0D17 = $0D17
f0D24 = $0D24
f0DFF = $0DFF
f0E0C = $0E0C
f0E11 = $0E11
f0E14 = $0E14
f0E16 = $0E16
f0E17 = $0E17
f0E19 = $0E19
f0E1B = $0E1B
f0E1C = $0E1C
f0E1D = $0E1D
f0E20 = $0E20
f0E24 = $0E24
f0F00 = $0F00
f0F0A = $0F0A
f0F0F = $0F0F
f0F24 = $0F24
f0FFC = $0FFC
f0FFF = $0FFF
f100A = $100A
f1012 = $1012
f1018 = $1018
f1055 = $1055
f10FF = $10FF
f1110 = $1110
f1115 = $1115
f111C = $111C
f111D = $111D
f1120 = $1120
f1124 = $1124
f112A = $112A
f1141 = $1141
f120A = $120A
f120F = $120F
f1211 = $1211
f121D = $121D
f1220 = $1220
f1224 = $1224
f1355 = $1355
f13FF = $13FF
f1400 = $1400
f140A = $140A
f141C = $141C
f1424 = $1424
f150B = $150B
f150C = $150C
f150E = $150E
f1512 = $1512
f151D = $151D
f151E = $151E
f15FF = $15FF
f160E = $160E
f16FF = $16FF
f170E = $170E
f1712 = $1712
f180C = $180C
f180D = $180D
f1810 = $1810
f1812 = $1812
f1816 = $1816
f1818 = $1818
f181B = $181B
f1824 = $1824
f18FF = $18FF
f191F = $191F
f1922 = $1922
f1924 = $1924
f1928 = $1928
f1B0E = $1B0E
f1B11 = $1B11
f1B12 = $1B12
f1B1A = $1B1A
f1C0E = $1C0E
f1C1B = $1C1B
f1C1D = $1C1D
f1C24 = $1C24
f1CFF = $1CFF
f1D1C = $1D1C
f1D1E = $1D1E
f1D24 = $1D24
f1E0A = $1E0A
f1E28 = $1E28
f1F18 = $1F18
f1F1D = $1F1D
f1F1E = $1F1E
f1F55 = $1F55
f201C = $201C
f2024 = $2024
f20FF = $20FF
f2141 = $2141
f220A = $220A
f2224 = $2224
f240D = $240D
f240E = $240E
f2411 = $2411
f2416 = $2416
f241C = $241C
f241D = $241D
f2422 = $2422
f2426 = $2426
f2444 = $2444
f251C = $251C
f251D = $251D
f260C = $260C
f2645 = $2645
f271D = $271D
f2722 = $2722
f2941 = $2941
f2A11 = $2A11
f2A18 = $2A18
f2A1D = $2A1D
f2A22 = $2A22
f3000 = $3000
f3133 = $3133
f3800 = $3800
f3B3A = $3B3A
f3E3D = $3E3D
f3F30 = $3F30
f3FBF = $3FBF
f4055 = $4055
f4140 = $4140
f4150 = $4150
f4159 = $4159
f4250 = $4250
f4332 = $4332
f4355 = $4355
f491C = $491C
f4A44 = $4A44
f4B46 = $4B46
f4E4E = $4E4E
f5000 = $5000
f5001 = $5001
f5054 = $5054
f5055 = $5055
f5100 = $5100
f5200 = $5200
f5300 = $5300
f5356 = $5356
f5400 = $5400
f5405 = $5405
f5456 = $5456
f54C0 = $54C0
f5500 = $5500
f5505 = $5505
f55C1 = $55C1
f55C5 = $55C5
f55F0 = $55F0
f5959 = $5959
f5A46 = $5A46
f5C67 = $5C67
f6000 = $6000
f676E = $676E
f6A82 = $6A82
f6AF0 = $6AF0
f6E82 = $6E82
f6E8C = $6E8C
f702E = $702E
f7033 = $7033
f7038 = $7038
f7042 = $7042
f7047 = $7047
f7368 = $7368
f7864 = $7864
f7891 = $7891
f7FFD = $7FFD
fC3FF = $C3FF
fCFFF = $CFFF
fE038 = $E038
fFA3F = $FA3F
fFC00 = $FC00
fFC18 = $FC18
fFC31 = $FC31
fFF00 = $FF00
fFF0D = $FF0D
fFF1C = $FF1C
fFFFC = $FFFC
fFFFD = $FFFD
;
; **** ABSOLUTE ADRESSES **** 
;
a0000 = $0000
a0004 = $0004
a000D = $000D
a0018 = $0018
a0032 = $0032
a00C0 = $00C0
a00FC = $00FC
a0100 = $0100
a0105 = $0105
a0110 = $0110
a0112 = $0112
a0203 = $0203
a0208 = $0208
a0209 = $0209
a020F = $020F
a0224 = $0224
a0303 = $0303
a0306 = $0306
a0309 = $0309
a030D = $030D
a030F = $030F
a0311 = $0311
a040A = $040A
a050C = $050C
a0510 = $0510
a0606 = $0606
a060D = $060D
a0610 = $0610
a0612 = $0612
a070F = $070F
a07F8 = $07F8
a07F9 = $07F9
a07FA = $07FA
a07FB = $07FB
a0800 = $0800
a0809 = $0809
a080B = $080B
a0810 = $0810
a0812 = $0812
a0818 = $0818
a081F = $081F
a0900 = $0900
a0906 = $0906
a090B = $090B
a090C = $090C
a0912 = $0912
a0918 = $0918
a0A00 = $0A00
a0A02 = $0A02
a0A0F = $0A0F
a0A11 = $0A11
a0A12 = $0A12
a0A18 = $0A18
a0A1B = $0A1B
a0C0B = $0C0B
a0C0C = $0C0C
a0C17 = $0C17
a0D02 = $0D02
a0D05 = $0D05
a0D07 = $0D07
a0D0C = $0D0C
a0D0E = $0D0E
a0D10 = $0D10
a0D13 = $0D13
a0D15 = $0D15
a0D18 = $0D18
a0E0D = $0E0D
a0E0E = $0E0E
a0E0F = $0E0F
a0E10 = $0E10
a0E12 = $0E12
a0E13 = $0E13
a0E15 = $0E15
a0E1F = $0E1F
a0F08 = $0F08
a1007 = $1007
a1009 = $1009
a100F = $100F
a1013 = $1013
a1024 = $1024
a105F = $105F
a1201 = $1201
a120C = $120C
a121B = $121B
a1228 = $1228
a12FF = $12FF
a1301 = $1301
a130B = $130B
a140E = $140E
a14FF = $14FF
a1500 = $1500
a150A = $150A
a150D = $150D
a1515 = $1515
a1524 = $1524
a15C0 = $15C0
a160A = $160A
a1624 = $1624
a1718 = $1718
a171C = $171C
a1815 = $1815
a181D = $181D
a1918 = $1918
a1921 = $1921
a1B14 = $1B14
a1B18 = $1B18
a1B1D = $1B1D
a1BFF = $1BFF
a1C0A = $1C0A
a1C0D = $1C0D
a1C1C = $1C1C
a1D0C = $1D0C
a1D17 = $1D17
a1E00 = $1E00
a1E0C = $1E0C
a2018 = $2018
a210E = $210E
a2215 = $2215
a2414 = $2414
a2415 = $2415
a2418 = $2418
a241B = $241B
a2420 = $2420
a2424 = $2424
a2428 = $2428
a242A = $242A
a24FF = $24FF
a2626 = $2626
a271B = $271B
a2A1B = $2A1B
a2C35 = $2C35
a3018 = $3018
a303F = $303F
a3600 = $3600
a3632 = $3632
a3A30 = $3A30
a3C00 = $3C00
a3C28 = $3C28
a3E1E = $3E1E
a3F1F = $3F1F
a4118 = $4118
a4249 = $4249
a4405 = $4405
a4544 = $4544
a473F = $473F
a483F = $483F
a4A24 = $4A24
a505C = $505C
a55C0 = $55C0
a5FFF = $5FFF
a6174 = $6174
a7012 = $7012
a7013 = $7013
a7014 = $7014
a7015 = $7015
a7016 = $7016
a7017 = $7017
a7018 = $7018
a7019 = $7019
a701A = $701A
a701B = $701B
a7021 = $7021
a7022 = $7022
a7030 = $7030
a7031 = $7031
a7032 = $7032
a703D = $703D
a704D = $704D
a704E = $704E
a7051 = $7051
aC8BB = $C8BB
aDFFF = $DFFF
aE000 = $E000
aEA0F = $EA0F
aEB3F = $EB3F
aF000 = $F000
aFBFF = $FBFF
aFCAA = $FCAA
aFF03 = $FF03
aFF0E = $FF0E
aFFFF = $FFFF
;
; **** POINTERS **** 
;
p6167 = $6167
;
; **** EXTERNAL JUMPS **** 
;
e0088 = $0088
e0E28 = $0E28
e1181 = $1181
e1484 = $1484
e1518 = $1518
e1B0A = $1B0A
e1C12 = $1C12
e2008 = $2008
e2321 = $2321
e2406 = $2406
e2617 = $2617
e2A17 = $2A17
e4495 = $4495
e4896 = $4896
e6595 = $6595
eE518 = $E518

        * = $8000 // L'adresse de début typique pour les cartouches sur le C64

        .BYTE $12,$80				// $8000-$8001, 32768-32769: Execution address of cold reset (Start address of game code). Reset Vector = $8012
		.BYTE $0C,$80				// $8002-$8003, 32770-32771: Execution address of non-maskable interrupt (NMI) service routine. NMI Vector = $800C (Les NMI sont déclenchées par des événements matériels : écran / touche RESTORE.)
		.BYTE $C3,$C2,$CD,$38,$30   // $8004-$8008, 32772-32776: Cartridge signature. If contains the uppercase PETSCII string "CBM80" 
									//($C3,$C2,$CD,$38,$30) then the routine vectors are accepted by the KERNAL.
        JMP j8026					// Used ???

		///////////////////////////////////////////////////
		// Non-maskable interrupt service routine        //
		// This NMI handler does nothing and then        //
		// disable the RESTORE key entirely.             //
		// So, simply restore registers push onto the    //
		// stack by ROM NMI routine.                     //
		// It is the same as rom $FEBC (return from NMI) //
		///////////////////////////////////////////////////
        PLA 
        TAY 
        PLA 
        TAX 
        PLA 
        RTI 

		/////////////////////////
		// Program starts here //
		/////////////////////////
		
		// Initialize display : no horizontal raster scroll, 40 columns, multicolor off
        LDX #$08
        SEI 		// Turn off interrupt since we will modify ROM overlay
        CLD 
        STX $D016   // VIC Control Register 2 (Activation du mode graphique "multicolore" (si activé via $D018) et réinitialisation du défilement horizontal fin à 0 pixels )

		/*** D64 version ***/
		// ROM overlay :
		// Default value at $1=$37 (%00110111)
		// It means, BASIC ROM visible at $A000-$BFFF, KERNAL ROM visible at $E000-$FFFF,
		// I/O area visible at $D000-$DFFF, datasette : motor OFF, no button pressed, 0 level signal.
		// Here, we want to disable BASIC ROM, then clear first bit (%00110110=36)
        SEI 
        LDA #$36
        STA a01
        CLI 
		
		// Fill vector table at memory addresses $0314-$0333 with default values.
        JSR $FD15    		//ROM_RESTOR - restore default I/O vectors      
		// Initialize VIC : restore default input/output to keyboard/screen; clear screen.
        JSR eE518
        CLI 
		/*** End of D64 version ***/
		
		/*** Cartridge version ***/
		/*

		// Call KERNAL routine IOINIT : 
		// Initialize CIA I/O Devices
		// This documented Kemal routine, which can be entered through the 
		// jump table at 65412 ($FF84), initializes the Complex Interface Adapter (CIA) devices, 
		// and turns the volume of the SID chip off. 
		// As part of this initialization, it sets CIA #1 Timer A to cause an IRQ interrupt every 
		// sixtieth of a second. 
		JSR $FDA3		// prepare irq (IOINIT : Initialize CIA's, SID volume; setup memory configuration; set and start interrupt timer)

		// Call KERNAL routine RAMTAS :
		// Perform RAM Test and Set Pointers to the Top and Bottom of RAM 
		// First, it clears Pages 0, 2, and 3 of memory to zeros. Next, it sets 
		// the tape buffer pointer to address 828 ($33C), and performs a nonde- 
		// structive test of RAM from 1024 ($400) up. When it reaches a non- 
		// RAM address (presumably the BASIC ROM at 40960, $A000), that 
		// address is placed in the top of memory pointer at 643-4 ($283-4). 
		// The bottom of memory pointer at 641-2 ($281-2) is set to point to 
		// address 2048 ($800), which is the beginning of BASIC program text. 
		// Finally, the pointer to screen memory at 648 ($288) is set to 4, which 
		// lets the Operating System know that screen memory starts at 1024 ($400). 
		JSR $FD50		

		// Call KERNAL routine RESTOR :
		// Restore RAM Vectors for Default I/O Routines .
		// It fills vector table at memory addresses $0314-$0333 with default values :
		// it sets the values for the 16 RAM vectors to the interrupt and important 
		// Kernal I/O routines in the table that starts at 788 ($314) to the standard 
		// values held in the ROM table at 64816 ($FD30) below.
		JSR $FD15		
		
		// Call KERNAL screen subroutine that initialize Screen and Keyboard :
		// initializes VIC, restores default input/output to keyboard/screen, clears screen.
		// After calling the routine at 58784 ($E5A0) to set up default I/O 
		// values, this routine initializes the cursor blink flags, the keyboard decode 
		// vector, the key repeat delay and frequency counters, the current 
		// color code, and maximum keyboard buffer size. It then falls through 
		// to the next routine at $E544.
		// Note : this call could be replace by KERNAL CINT at $FF5B. It is as newer patched
		// version that uses Raster IRQ to init PAL/NTSC register.
		JSR $E518       
		CLI
		*/
		/*** End of cartridge version ***/
		
		// Stop Timer A
        LDA $DC0E    ;CIA1: CIA Control Register A
        AND #$FE
        STA $DC0E    ;CIA1: CIA Control Register A
        
		// ROM overlay : 
		// Character ROM visible at $D000-$DFFF, RAM visible at $A000-$BFFF, KERNAL ROM visible at $E000-$FFFF.
		LDA a01
        AND #$FA     
        STA a01
		
		// On recopie une partie du charset ROM en RAM.
		// Cela resulte en un charset maison entre $4000 et $431F
		// qui sera recopié directement dans le bitmap par le moteur du jeu

		// Copy $D180-$D27F -> $4000-$40FF
		// Recopie la ROM char standard des caracteres ayant les screen code 48 ("0") -> 79 (upper left corner)
        LDA #$D1	; ($FB).w=$D180 (adresse en ROM Char du charactere '0')
        STA aFC
        LDA #$80
        STA aFB
        LDY #$00	; ($3B).w=$4000 (adresse cible de recopie de la ROM char)
        STY a3B
        LDA #$40
        STA a3C
b8044   LDA (pFB),Y
        STA (p3B),Y
        INY 
        BNE b8044
		
		// Recopie la ROM char des caracteres ayant les screen code 1 ("A") -> 79 ("<-")
		// a la suite des caracteres "0"..."9"
		// Copy $D008-$D0FF -> $4050-$4147
        DEC aFC
        LDA #$00
        STA aFB
        LDA #$48
        STA a3B
        LDY #$08
b8057   LDA (pFB),Y
        STA (p3B),Y
        INY 
        BNE b8057
        
		// Recopie depuis les data du programme @$BD20 les caracteres restants
		// (' ','.',',','?',...) et le logo MAZE MASTER sur 2 chars de large
		// Copy $BD20-$BF1F -> $4120-$431F (512 bytes = 64 chars) Note : Seul $BD20-$BE5F semble contenir des chars dans la rom (320 bytes = 40 chars)
		INC a3C
        LDA #$20
        STA a3B
        STA aFB
        LDA #$BD
        STA aFC
b806A   LDA (pFB),Y
        STA (p3B),Y
        INY 
        BNE b806A
		
        INC aFC
        INC a3C
        LDA aFC
        CMP #$BF
        BNE b806A
		
		// On cache a nouveau la ROM Char et rend visible la zone I/O a $D000-$DFFF
        LDA a01
        ORA #$04
        STA a01
		
		// Start Timer A
        LDA $DC0E    // CIA1: CIA Control Register A
        ORA #$01
        STA $DC0E    // CIA1: CIA Control Register A
        
		// Turn ON bitmap mode
		LDA $D011    
        ORA #$20	  
        STA $D011    // (VIC Control Register 1)
        
		// Bitmap will be located at $2000
		LDA $D018    
        ORA #$08	  
        STA $D018    // (VIC Memory Control Register)
		
        LDA #$81
        STA $D412    // Voice 3: Control Register
        LDA #$FF
        STA $D40F    // Voice 3: Frequency Control - High-Byte
       
	    // Copy squares triggers into RAM (since they can be disabled and cannot be changed in cartridge ROM)
	    // Copy $AB90-$ABFF -> $C000-$C06F
		// Copy $AD90-$ADFF -> $C100-$C16F
		// Copy $AF90-$AFFF -> $C200-$C26F
		// Copy $B190-$B1FF -> $C300-$C36F
		// Copy $B390-$B3FF -> $C400-$C46F
        LDA #$90
        STA aFB
        LDA #$00
        STA a3B
        LDA #$AB
        STA aFC
        LDA #$C0
        STA a3C
        LDY #$00
b80B5   LDA (pFB),Y
        STA (p3B),Y
        INY 
        CPY #$70
        BNE b80B5
		
	    LDY #$00
        INC aFC
        INC aFC
        INC a3C
        LDA a3C
        CMP #$C5
        BNE b80B5
		
		// Initialise les noms des personnages avec le caractere ' '
		// $0800->$080F (regions utilisées normalement pour le programme basic)
		// $0900->$090F
		// $0A00->$0A0F
        LDA #$00
        STA aFB
        LDA #$08
        STA aFC
b80D4   LDY #$00
b80D6   LDA #$24
        STA (pFB),Y
        INY 
        CPY #$10
        BNE b80D6
        INC aFC
        LDA aFC
        CMP #$0B
        BNE b80D4
		
// Initialise la table des offsets (LSB) du premier octet du premier block d'une screen row donnée...
// $5000->5020 = $00,$40,$80,$C0,$00,$40,etc...
        LDA #$00
        TAX 
b80EA   STA f5000,X			// store LSB of bitmap address offset of first 8x8 block at screen row X
        CLC 
        ADC #$40
        INX 
        CPX #$21
        BNE b80EA
		
// Initialise la table des offset (LSB) du premier octet d'une screen column donnée relativement 
// au premier octet de la premiere colonne sur la même ligne
// $5100->$5150 = $00,$08,$10,$18,etc...
        LDA #$00
        TAX 
b80F8   STA f5100,X
        CLC 
        ADC #$08
        INX 
        CPX #$51
        BNE b80F8
		
// Initialise la table des offset (MSB) du premier octet d'une screen column donnée relativement 
// au premier octet de la premiere colonne sur la même ligne
// $5200->$5250
        LDA #$00
        TAX 
b8106   STA f5200,X
        INX 
        CPX #$40
        BEQ b8116
        CPX #$51
        BEQ b811C
        CPX #$20
        BNE b8106
b8116   CLC 
        ADC #$01
        JMP b8106

// Compute dodge score table.
// A score depends on Armor Rating, used as index in this table
// (score = $1C for an AR of -10 and score = $08 for an AR of +10)
// Store values $1C..$08 at $5300..$5314
b811C   LDA #$1C
        LDX #$00
b8120   STA f5300,X
        INX 
        SEC 
        SBC #$01
        CPX #$15
        BNE b8120

// Precomputed table: LSB of square offset for this YPos
        LDA #$00
        TAX 
b812E   STA f5400,X
        CLC 
        ADC #$14
        INX 
        BNE b812E
		
j8137   JSR s9492	 // Clear whole menu screen
        LDA #$0F
        STA $D020    // Border Color
        JSR s9C99	 // Display menu HEADER
        JSR s9D2C	 // Display menu FOOTER
		
// Affichage du menu principal avec les 5 choix
b8145   JSR s9DEF    // clear menu
        JSR s9E12    // display 5 choices (center part)
		
// Lecture de la touche pressée dans le menu principal		
b814B   JSR s9E8E	 // Lecture bloquante touche clavier
        SEC 
        SBC #$31     // on enleve $31 au code petscii de la touche pressée ($31='1')
        CMP #$05     // Si on a pressé une touche > 5, on boucle sur la lecture clavier
        BCS b814B
        CMP #$00	 // Touche '1' ?
        BEQ b8171    // -> new character
        CMP #$04     // Touche '5' ?
        BEQ b8168    // -> enter the maze
        CMP #$02     // Touche '3' ?
        BEQ b816B    // -> examine character
        CMP #$03     // Touche '4' ?
        BEQ b816E    // -> delete character
        JMP j851C    // else -> buy item

b8168   JMP j8602    // -> enter the maze

b816B   JMP j82E9    // -> examine character

b816E   JMP j818A    // -> delete character

//////////////////////////////
// Look for empty character //
//////////////////////////////
b8171   LDA #$08		// Lecture du premier caractere du premier personnage ($0800)
        STA a3C
        LDY #$00
        STY a3B
b8179   LDA (p3B),Y
        CMP #$24		// Si le nom est vide (char == " "),
        BEQ b81CD		// on poursuit le processus de creation
        INC a3C			// sinon, on test le personnage suivant
        LDA a3C
        CMP #$0B
        BNE b8179
        JMP b814B		// aucun personne sans nom ? on reboucle la lecture clavier du menu principal

//////////////////////
// delete character //
//////////////////////
j818A   JSR s9DEF       // Clear main screen menu
		
// Ouput screen codes 0D,0E,15,0E,1D,0E,24,0C,11,0A,1B,0A,0C,1A,0E,1B,24,01,49,03,24,4A,00,2A,17,18,17,0E,28 at (9,8)
// that matches chars "DELETE CHARACTER 1-3 (0:NONE)"
        LDA #$08		// row 8
        STA a4A
        LDA #$06		// column 6
        STA a49
        LDX #$00
b8197   LDA fB7E2,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$1D
        BNE b8197
		
// Let player choose the caracter number to delete
b81A2   JSR s9E8E			// Lecture bloquante touche clavier
        SEC 
        SBC #$30
		
		// If an other key than 0..3 has been pressed, loop on get input
        CMP #$04
        BCS b81A2
		
		// Zero pressed ?
        CMP #$00
        BEQ b8145		// return to main menu
		
		// Delete character 1 ?
        CMP #$01
        BNE b81BA
        JSR sA0BE		// delete character 1 data
        JMP j81C7
		
		// Delete character 2 ?
b81BA   CMP #$02
        BNE b81C4
        JSR sA0C9		// delete character 2 data
        JMP j81C7

		// Delete character 3...
b81C4   JSR sA0D4		// delete character 3 data
j81C7   JSR s9D2C		// Display menu FOOTER
        JMP b8145		// Return to main menu (5 choices)

////////////////////////////////////////////////////////
// Create new character                               //
// ($3B,$3C).w pointe vers le nom du personnage libre //
////////////////////////////////////////////////////////
b81CD   JSR s9DEF  		   	// clear menu
        JSR s84EF		   	// Put cursor at (7,7) for char output, and reset X
        STX a76
        STX a7A			   	// Reset random character flag
		
// Ouput screen codes 1B,0A,17,0D,18,16,12,23,0E,27,24,4A,22,49,17,28 at (?,?)
// that matches chars "RANDOMIZE? (Y-N)"
b81D7   LDA fA9B3,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$10
        BNE b81D7
		
b81E2   JSR s9E8E			// Lecture bloquante touche clavier
        CMP #$4E			// 'N' pressed ?
        BEQ b81EF
        CMP #$59			// 'Y' pressed ?
        BNE b81E2			// If not, loop on get input
        INC a7A				// ($7A)=1 if random char

b81EF   JSR s9DEF			// clear menu
        JSR s84EF			// Put cursor at (7,7) for char output, and reset X
		
// Ouput screen codes 17,0A,16,0E,2A,24 at (7,7)
// that matches chars "NAME: "
b81F5   LDA fA6A7,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$06
        BNE b81F5
	
// Lecture du tampon de saisie (10 caracteres at $0B00)
// et stockage dans le nom du personnage libre	
        JSR sA003			// Read 10 characters (max) from keyboard
        LDY #$00
b8205   LDA f0B00,Y
        STA (p3B),Y
        INY 
        CPY #$10
        BNE b8205
		
// RAZ des données du personnage ($0810->$08FF pour le personnage 1)
b820F   LDA #$00
        STA (p3B),Y
        INY 
        BNE b820F
		
        INC a4A			// next row
        LDA #$06
        STA a86
        STA a87			// first char offset relative to $A6A7 of string to display ($6 for "STRENGTH")
		
        LDA a7A			// Random character ?
        BEQ b8225		// if not, continue
        JMP j84B6		// else, jump to random generation

// Create custom char
b8225   LDA #$00
        STA a39			// initialization of character code to parse index (0..20)
        STA a74			// initialization of read position in input buffer (0..6)
        STA a88			// offset of char to display initialized with 0
b822D   LDX a88			// initialize X with char index of string to display
        INC a4A			// next row
        LDA #$07		// column 7
        STA a49
// Ouput screen codes 0C,18,0D,0E,24,01,2A,24,FF at (7,9)
// that matches chars "CODE 1: "
j8235   LDA fA9D9,X
        CMP #$FF
        BEQ b8243
        JSR s9E94		// Output char in AC
        INX 			// increment string char index
        JMP j8235

b8243   INX 			// increment string char index
        STX a88			// ($88)=index of next char to display
        JSR s9FF5		// lit 7 caracteres depuis le clavier

// Read flipping byte (EOR) matching this code character index (offset 0..20)
// and store it at $73. 
// Note that the flipping byte also equal the offset of current attribute in character data !
b8249   LDX a39
        LDA fA396,X
        TAY 			// flipping byte is also character field offset. Store it in Y
        STA a73
// Does this code char encore the upper or lower 4 bits of character data ?
// If it encodes upper bytes, read CODE char, flip bytes and shift 4 bits left
        LDA fA3AB,X
        BEQ b8264
		
        LDX a74			// read input character with current position in buffer
        LDA f0B00,X
        EOR a73			// flip byte
        ASL 
        ASL 
        ASL 
        ASL 
        JMP j826D

// Else, if it encode lower bytes, read CODE char and flip bytes
b8264   LDX a74
        LDA f0B00,X
        EOR a73
        AND #$0F
		
j826D   ORA (p3B),Y		// merge these 4 bits with bits already stored for this field
        STA (p3B),Y
        INC a39			// increment character code to parse index
        INC a74			// increment read position in buffer
        LDA a74
        CMP #$07		// 7 characters read ?
        BNE b8249		// if not, parse next character in buffer
        LDA #$00		// else reset position index in read buffer
        STA a74
		
        LDA a39			// Check character index to parse (0..20)
        CMP #$15		// 21 characters code read ?
        BNE b822D		// if not, loop on 
        INC a4A			// else, next row
	
// Check attributes. Ensure : 
// strength < $13 (0->18)
// intellect < $13 (0->18)
		LDY #$10
b8289   LDA (p3B),Y
        CMP #$13
        BCS b82AD			// reset all character attributes expect name
        INY 
        CPY #$13			// next field to check is 'constitution' ?
        BCC b8289			// if not, loop on first 3 attributes
        INY 				// else, skip constitution check
        LDA (p3B),Y			// ensure class is >0 and <3
        BEQ b82AD			// reset all character attributes expect name
        CMP #$03
        BCS b82AD			// reset all character attributes expect name

// Check items : if one item slot (offsets $19,$1A,$1B,$1C)
// has an item ID >= 5, reset all character attributes
        LDY #$19
b829F   LDA (p3B),Y
        CMP #$05
        BCS b82AD			// reset all character attributes expect name
        INY 
        CPY #$1D
        BCC b829F
        JMP j82E3			// Update footer, display main menu

// reset all character attributes expect name
b82AD   LDY #$10
b82AF   LDA #$00
        STA (p3B),Y
        INY 
        BNE b82AF
        JMP j82E3			// Update footer, display main menu

// Ouput screen codes 0C,15,0A,1C,1C,24,4A,01,49,20,0A,1B,24,24,02,49,20,12,23,28,2A at (7,9)
// that matches chars "CLASS (1-WAR  2-WIZ):"
j82B9   LDA #$07
        STA a49
        LDX #$00
b82BF   LDA fA717,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$15
        BNE b82BF

b82CA   JSR s9E8E			// Lecture bloquante touche clavier
        SEC 
        SBC #$31
        CMP #$02			// "1" or "2" key pressed ?
        BCS b82CA			// if not, loop on get input
        CLC 
        ADC #$01
        LDY #$14			// store class type (1 or 2) at offset $14
        STA (p3B),Y			// of caracter date (i.e $0814, $0914 or $0A14)
        JSR s9E94			// Output char in AC
        INC a4A				// Next row
        JMP j84DB			// Generate random gold and reset following data (experience, items, ...)

j82E3   JSR s9D2C			// Display menu FOOTER
        JMP b8145			// Return to main menu (5 choices)

///////////////////////
// examine character //
///////////////////////
j82E9   JSR s9DEF			// clear menu

// Ouput screen codes 0E,21,0A,16,12,17,0E,24,20,11,12,0C,11,24,01,49,03,24,4A,00,49,17,18,17,0E,28 at (7,7)
// that matches chars "EXAMINE WHICH 1-3 (0-NONE)"
        LDA #$07
        STA a49
        LDA #$08
        STA a4A				
        LDX #$00
b82F6   LDA fA739,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$1A
        BNE b82F6
		
b8301   JSR s9E8E			// Lecture bloquante touche clavier
        SEC 				// Ensure that pressed key is 0..3
        SBC #$30
        CMP #$04
        BCS b8301
        CMP #$00			// '0' key pressed ?
        BEQ b8322			// if true, return to main menu (5 choices)
        CLC 
        ADC #$07			// Store concerned character data start address in ($3B).w
        STA a3C
        LDA #$00
        STA a3B
        LDY #$00			// If no character has been created in this slot, loop on get input
        LDA (p3B),Y
        CMP #$24
        BEQ b8301
        BNE b8325			// Character exists, clear menu and start examining...
b8322   JMP b8145			// Return to main menu (5 choices)

b8325   JSR s9DEF  			// clear menu

// Display character name at (5,6)
        LDA #$06			// row number 6
        STA a4A
        LDA #$05			// column number 5
        STA a49
        LDY #$00
b8332   LDA (p3B),Y
        JSR s9E94			// Output char in AC
        INY 
        CPY #$10
        BNE b8332

// Ouput screen codes 1D,11,0E,24 at (22,6)
// that matches chars "THE "
        INC a49				// Increase column
        LDX #$00
b8340   LDA fA753,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$04
        BNE b8340
	
// According to the class field, display either 'THE WARRIOR' or 'THE WIZARD'
        LDX #$00
        LDY #$14
        LDA (p3B),Y
        CMP #$01
        BEQ b8357
        LDX #$07
// Ouput screen codes 20,0A,1B,1B,12,18,1B or 20,12,23,0A,1B,0D,0E at (26,6)
// that matches chars "WARRIOR" or "WIZARD"
b8357   LDA fA72C,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$07
        BEQ b8366
        CPX #$0D
        BNE b8357
		
b8366   INC a4A				// next row (7)
        LDA a49				// save current column in $87
        STA a87
        LDX #$05			// column 5
        STX a49
b8370   LDA #$29			// write char '-' till saved column position in $87
        JSR s9E94			// Output char in AC
        INX 
        CPX a87
        BNE b8370
		
// Ouput screen codes 1C,1D,1B,0E,17,10,1D,11,2A,24 at (5,8) 
// that matches chars "STRENGTH: "
        INC a4A				// next row (8)
        LDA #$06			// first char offset relative to $A6A7 of string to display
        STA a87
        LDA #$00			// Strength is stored in a byte. Clear $76 which contains MSB of a word to display
        STA a76				
        JSR s848F			// Display a string, starting a column 5, on current row.
// Display strength byte value
        LDY #$10			// Load strengh value and
        LDA (p3B),Y			// store it in the LSB of word to display
        STA a75
        JSR sA1ED			// Display word value stored in ($75).w
		
// Ouput screen codes 12,17,1D,0E,15,15,0E,0C,1D,2A,24 at (19,8) 
// that matches chars "INTELLECT: "
        INC a49				// Skip 2 columns
        INC a49
        JSR s8493			// Display a string delimited by $FF, at current column, current row.
        LDY #$11			// Load strengh value and
        LDA (p3B),Y	
        STA a75				// store it in the LSB of word to display
        JSR sA1ED			// Display word value stored in ($75).w

// Ouput screen codes 0D,0E,21,1D,0E,1B,12,1D,22,2A,24 at (5,9) 
// that matches chars "DEXTERITY: "
        INC a4A				// next row (9)
        JSR s848F			// Display a string, starting a column 5, on current row.
        LDY #$12
        LDA (p3B),Y			// Load dexterity value and
        STA a75
        JSR sA1ED			// Display word value stored in ($75).w
		
// Ouput screen codes 0C,18,17,1C,1D,12,1D,1E,1D,12,18,17,2A,24 at (20,9) 
// that matches chars "CONSTITUTION: "
        INC a49				// Skip 2 columns
        INC a49
        JSR s8493			// Display a string delimited by $FF, at current column, current row.
        LDY #$13			// Load constitution value and
        LDA (p3B),Y
        STA a75
        JSR sA1ED			// Display word value stored in ($75).w

// Ouput screen codes 10,18,15,0D,2A,24,FF at (5,10) 
// that matches chars "GOLD: "
        INC a4A				// next row (10)
        JSR s848F			// Display a string, starting a column 5, on current row.
        LDY #$15			// Load LSB of GOLD word value
        LDA (p3B),Y
        STA a75				// and store it in ($75).w
        INY 				// Load MSB of GOLD word value
        LDA (p3B),Y
        STA a76				// and store it in ($76).w
        JSR sA1ED			// Display word value stored in ($75).w

// Ouput screen codes 0E,21,19,0E,1B,12,0E,17,0C,0E,2A,24 at (5,10) 
// that matches chars "EXPERIENCE: "
        INC a49				// Skip 2 columns
        INC a49
        JSR s8493			// Display a string delimited by $FF, at current column, current row.
        LDY #$17			// Load LSB of EXPERIENCE word value
        LDA (p3B),Y
        STA a75				// and store it in ($75).w
        INY 				// Load MSB of EXPERIENCE word value
        LDA (p3B),Y
        STA a76				// and store it in ($76).w
        JSR sA1ED			// Display word value stored in ($75).w
		
// Ouput screen codes 12,1D,0E,16,1C,2A at (5,10) 
// that matches chars "ITEMS :"
        INC a4A				// Next row (11)
        LDA #$05			// Column 5 (11)
        STA a49
        LDX #$04
b83EE   LDA fA753,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$0A
        BNE b83EE
		
        LDA #$18
        STA a87				// Initialize item OFFSET in ($87)
b83FD   INC a4A				// Next row (12)
        LDA #$05			// Column 5 (11)
        STA a49
        INC a87				// Increment item OFFSET (=$19 for first item)
        LDA a87
        CMP #$1D			// All items processed ?
        BEQ b842E			// If true, stop items and dispay character CODE
        TAY 				// Load item identifier of current slot
        LDA (p3B),Y
        BEQ b841B			// If no item defined, skip item number computation
j8410   CPY #$19			// Else, item number = item identifier + 4*item slot number
        BEQ b841B			// e.g third slot items have numbers in range $8..$B
        CLC 
        ADC #$04
        DEY 
        JMP j8410

b841B   TAX 				// Items name offset are stored in a table store at $A42C
        LDA fA42C,X			// Get name offset of current item
        TAX 
j8420   LDA fBF00,X			// Display item name at address $BF00+offset, delimited with char $FF
        CMP #$FF
        BEQ b83FD			// If ending char of name reached, display next item
        JSR s9E94			// Output char in AC
        INX 
        JMP j8420

// Ouput screen codes 0C,18,0D,0E,2A,24 at (5,15) 
// that matches chars "CODE: "
b842E   LDX #$00
        STX a39				// Initialize current index of CODE character 
        STX a74				// Initialize char index in CODE group
b8434   LDA fA9F4,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$06
        BNE b8434
		
b843F   LDX a39				// Load the flipping byte (and also attribute data offset) for this character index
        LDA fA396,X
        TAY 
        STA a73				// Save flipping byte
        LDA fA3AB,X			// Does this code char encore the upper or lower 4 bits of character data ?
        BEQ b8459			// If lower part, skip logical shift of value
        LDA (p3B),Y			// Load attribute value, shift 4 bits right 
        LSR 
        LSR 
        LSR 
        LSR 
        EOR a73				// Flip byte
        AND #$0F			// Mask result
        JMP j845F			// Display resulting char

b8459   LDA (p3B),Y			// Else, if this char encore le lower 4 bits 
        EOR a73				// Flip byte
        AND #$0F			// Mask result
j845F   JSR s9E94			// Output char in AC

        INC a74				// Increment char index in CODE group
        INC a39				// Increment current index of CODE character 
        LDA a74				// Is a 7 chars CODE group displayed ?
        CMP #$07
        BNE b843F			// If not, computer and display next CODE character
        LDA #$00			// Else, reset char index in CODE group
        STA a74
        INC a49				// Skip one column
        LDA a39				// All CODE characters displayed ?
        CMP #$15			
        BNE b843F			// If not, loop on next character
		
        INC a4A				// Next row (16)
j847A   LDX #$0A			// Column 10
        STX a49
// Ouput screen codes 11,12,1D,24,0A,17,22,24,14,0E,22,24,1D,18,24,10,18,24,18,17,1C at (5,15) 
// that matches chars "HIT ANY KEY TO GO ON"
b847E   LDA fA753,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$1E
        BNE b847E
        JSR s9E8E			// Lecture bloquante touche clavier
        JMP b8145			// Return to main menu (5 choices)

//////////////////////////////////////////////////////////////////////
// Display a string, starting a column 5, on current row.
// String must have the $FF end delimiter
//
// Input : $87 contains the first char offset relative to $A6A7
// Output : $87 points to the first char of the next string to display
//////////////////////////////////////////////////////////////////////
s848F   LDA #$05			// column 5
        STA a49
// Display a string at current column, current row.
// String must have the $FF end delimiter
s8493   LDX a87				
j8495   LDA fA6A7,X
        CMP #$FF
        BEQ b84A3
        JSR s9E94			// Output char in AC
        INX 
        JMP j8495

b84A3   INX 
        STX a87
        RTS 

////////////////////////////////////////////////////////////////////////
// Display a string, starting on next row of message windows (column 22)
// String must have the $FF end delimiter
//
// Input : $87 contains the first char offset relative to $A6A7
// Output : $87 points to the first char of the next string to display
////////////////////////////////////////////////////////////////////////
s84A7   JSR sA36D			// One line return in message window and reset X
        JMP s8493

//////////////////////////////////////////////////////////////////////
// Return to next line, column 7, and display 
// next string at $A6A7+offset stored at $87
//
// Input : $87 contains the first char offset relative to $A6A7
// Output : $87 points to the first char of the next string to display
//////////////////////////////////////////////////////////////////////
s84AD   INC a4A
        LDA #$07
        STA a49
        JMP s8493

/////////////////////////////////
// Random character generation //
/////////////////////////////////
j84B6   JSR s84AD		// Display "STRENGTH" at next row, column 7
        LDY #$10
        JSR s84F8
        JSR s84AD		// Display "INTELLECT" at next row, column 7
        LDY #$11
        JSR s84F8
        JSR s84AD		// Display "DEXTERITY" at next row, column 7
        LDY #$12
        JSR s84F8
        JSR s84AD		// Display "CONSTITUTION" at next row, column 7
        LDY #$13
        JSR s84F8
        INC a4A			// Next row
        JMP j82B9	 	// return to character creation routine

//////////////////////////////////////////////////////
// Generate random gold for current character (64-255)
// and reset following data (experience, items, ...)
////////////////////////////////////////////////////// 
j84DB   LDA $D41B    	// read Oscillator 3 Output for random value
        ORA #$40		// ensure gold is at least 64
        LDY #$15		// gold is at offset $15 of character data
        STA (p3B),Y
        INY 
b84E5   LDA #$00
        STA (p3B),Y
        INY 
        BNE b84E5
        JMP j82E3		// update footer, display main menu

//////////////////////////////////////////////////////
// Put cursor at (7,7) for char output, and reset X //
//////////////////////////////////////////////////////
s84EF   LDA #$07
        STA a4A
        STA a49
        LDX #$00
        RTS 

///////////////////////////////////////////////
// Generate a random value between ($6..$12),
// store it in character data at offset ($47).b
// and diplay value at current cursor location

s84F8   STY a47			// save attribute offset in ($47), relative to start of character data area
        LDA $D41B    	// load a random value (Note : pourquoi aléatoire et pas fixer à 3 ???
        AND #$03		// car on utilise aussi une valeur aléatoire ensuite <= $0F)
        STA a73			// store a random value (0..3) in $73
        JSR s9C62		// waiting loop
b8504   LDA $D41B    	// Generate random value ($3..$12) -> ($6..$12) in A
        ORA a73			
        AND #$0F
        CLC 
        ADC #$03
        CMP #$06		// Loop while generated value < $6
        BCC b8504
        LDY a47			// reload attribute offset
        STA (p3B),Y		// store random value in attribute field
        STA a75			// Display attribute value next to attribute name
        JSR sA1ED		// Display word value stored in ($75).w
        RTS 

/////////////////////////////////////////
// Buy an item 
/////////////////////////////////////////
j851C   JSR s9DEF			// Clear menu
// Ouput screen codes 20,11,18,24,20,12,15,15,24,0B,1E,22,27,24,01,49,03,24,4A,00,2A,17,18,17,0E,28 at (7,7) 
// that matches chars "WHO WILL BUY? 1-3 (0:NONE)"
        LDA #$07			
        STA a49				// Row 7
        STA a4A				// Column 7
        LDX #$00
b8527   LDA fA77C,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$1A
        BNE b8527
		
b8532   JSR s9E8E			// Lecture bloquante touche clavier
        SEC 
        SBC #$30			// Touche >= 4 ?
        CMP #$04
        BCS b8532			// Si oui, boucle sur la lecture clavier
        CMP #$00			// Si touche '0', alors retour au menu
        BNE b8543
        JMP b8145			// Return to main menu (5 choices)

b8543   CLC 				// Stockage de l'address de debut des données du personnage
        ADC #$07			// dans ($3B).w
        STA a3C
        LDY #$00
        LDA (p3B),Y
		
        CMP #$24			// Si le personnage n'existe pas, on boucle sur la lecture clavier
        BEQ b8532
		
// Ouput screen codes 1D,22,19,0E,24,4A,01,49,20,0E,24,02,49,0A,1B,24,03,49,1C,11,24,04,49,16,12,28,27 at (7,9) 
// that matches chars "TYPE (1-WE 2-AR 3-SH 4-MI)?"		
        INC a4A				// Next row (8)
        INC a4A				// Next row (9)
        LDA #$07			// Column 7
        STA a49
        LDX #$00
b855A   LDA fA796,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$1B
        BNE b855A
		
b8565   JSR s9E8E			// Lecture bloquante touche clavier
        SEC 
        SBC #$31
        CMP #$04			// Touche >= 4 ?
        BCS b8565			// Si oui, boucle sur la lecture clavier
        STA a87				// Stockage type d'item dans ($87).b
        CLC 
        ADC #$01			// Affichage de la categorie selectionnée
        JSR s9E94			// Output char in AC
		
// Ouput screen codes 12,1D,0E,16,24,17,1E,16,0B,0E,1B,27,24,4A,01,49,04 (7,10) 
// that matches chars "ITEM NUMBER?: (1-4)"	
        INC a4A				// Next row (10)
        LDA #$07			// Column 7
        STA a49
        LDX #$00
b857F   LDA fA7B1,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$12
        BNE b857F
		
b858A   JSR s9E8E			// Lecture bloquante touche clavier
        SEC 
        SBC #$31
        CMP #$04			// Touche >= 4 ?
        BCS b858A			// Si oui, boucle sur la lecture clavier
        TAX 				// Save item number (0..3) (category based)
        CLC 
        ADC #$01			// Display item number
        STA a46				// Save item number in $46 (1..4) (category based)
        JSR s9E94			// Output char in AC
        TXA 				// Restore item number (0..3)
        LDX a87
j85A0   CPX #$00			// Compute absolute item number (0..15)
        BEQ b85AB
        DEX 
        CLC 
        ADC #$04
        JMP j85A0

b85AB   ASL 				// A contains the absolute item number
        TAX 				// Let use X as an offset in item PRICE array (which starts at $BFC0)
        LDA fBFC0,X			// Store LSB of item price in $75
        STA a75
        LDA fBFC1,X			// Store MSB of item price in $76
        STA a76
        LDY #$16			// Compare MSB of character gold to MSB of item price
        LDA (p3B),Y
        CMP a76
        BCC b85CB			// If MSB of gold is lower, reject buy
        BEQ b85C4			// If MSB are equal, compare LSB
        JMP j85E5			// Enough gold, add item to inventory

b85C4   DEY 				// Compare LSB of character gold to LSB of item price
        LDA (p3B),Y
        CMP a75
        BCS j85E5			// Enough gold, add item to inventory
		
b85CB   INC a4A				// Next row (11)
        LDA #$0B			// Column 11
        STA a49
        LDX #$00
// Ouput screen codes 12,17,1C,1E,0F,0F,12,0C,12,0E,17,1D,24,0F,1E,17,0D,1C at (11,11) 
// that matches chars "INSUFFICIENT FUNDS"
b85D3   LDA fA7C3,X
        JSR s9E94			// Output char in AC
        INX 
        CPX #$12
        BNE b85D3
		
j85DE   INC a4A				// next row (12)
        INC a4A				// next row (13)
        JMP j847A			// Display "HIT ANY KEY TO GO ON" and wait for keyboard input to go back to menu

// Remove item price from the character gold
j85E5   LDY #$15
        LDA (p3B),Y
        SEC 
        SBC a75
        STA (p3B),Y
        INY 
        LDA (p3B),Y
        SBC a76
        STA (p3B),Y
		
        LDA a87				// load item category number (0..3)
        CLC 
        ADC #$19			// compute offset of item slot in character data
        TAY 
        LDA a46				// load item number in its category
        STA (p3B),Y			// store item number in the item slot
        JMP j85DE			// Display "HIT ANY KEY TO GO ON" and wait for keyboard input to go back to menu

/////////////////////
// Enter the maze !!!
/////////////////////

// First, ensure that there is a least one character in party
j8602   LDA a0800			
        CMP #$24
        BNE b860C
        JMP b814B			// First character is empty ? Loop on main menu keyboard read

b860C   LDA #$08			// Initialize character data pointer ($3B).w
        STA a3C
        LDA #$00
        STA a3B
        STA a81				// Turn off the light

// Initialize some character attributes when entering maze (CND, EXP copy, Spell points)		
b8616   LDY #$00			// Load name of current character
        LDA (p3B),Y
        CMP #$24			// Empty character slot ?
        BEQ b8670			// If so, ....

// Initialize character condition (offset $1D) with its constitution
        LDY #$13			
        LDA (p3B),Y
        LDY #$1D
        STA (p3B),Y

// Copy character experience to offsets $1E,$1F
        LDY #$17
        LDA (p3B),Y
        LDY #$1E
        STA (p3B),Y
        LDY #$18
        LDA (p3B),Y
        LDY #$1F
        STA (p3B),Y
		
// Reset character spell points
        LDY #$21
        LDA #$00
        STA (p3B),Y

// Loof for a Staff of light item in inventory		
        LDY #$1C			// Load fourth item identifier
        LDA (p3B),Y
        CMP #$01			// Staff of light ?
        BNE b8648
        LDA #$FA			// If true, ($81).b = $FA
        STA a81				

// Initialize spell points of wizards.
// It equals to 1 + lvl + (intellect - $0F, if intellect > $0F) 
b8648   LDY #$14			// Load class identifier
        LDA (p3B),Y
        CMP #$01			// Is it a warrior ?
        BEQ b8668			// If true, skip this part and process next character
        LDY #$18			// Else, load MSB of experience
        LDA (p3B),Y
        LSR 				// Divide it by 4 to gain level number (1024XP = 1lvl)
        LSR 
        STA a87				// Store in $87...
        LDY #$11			// Load intellect
        LDA (p3B),Y
        JSR sA376			// Compute X=A-$0F, if X>$0F (bonus for high stat)
        INX 				// Add at least 1 spell point
        TXA 
        CLC 
        ADC a87
        LDY #$21			// Store spell points at offset $211
        STA (p3B),Y
b8668   INC a3C				// Process next character
        LDA a3C
        CMP #$0B
        BNE b8616
		
// Change border color of screen when in maze (blue)
b8670   LDA #$06
        STA $D020    ;Border Color

// Reset some variables (TO IDENTIFY)
        LDA #$00
        STA a48			// set YPos = 0
        STA a62			// set XPos = 0
        STA a65			// reset orientation to NORTH
        STA a84			// enter level floor 0
        STA a7021		// first main loop counter (LSB)
        STA a7012		// second main loop counter (MSB)
        STA a7022		// third main loop counter (byte:0..1), used for light decline and healing
        STA a704E		// magic armor
        LDA #$0B
        STA a67
		
        JSR s93E9		// Clear bitmap and initialize screen colors
        JSR s93A2		// Clear 3D view and draw border
        JSR s9EE1		// Initialize maze view footer, master master logo and sprites 0-3
        JSR s9BEA		// Deactivate wandering monstering according to party level and maze floor number.
		JSR s8DB1		// Draw 3D view content

b869E   JSR $FFE4    	// Read keyboard        
        BEQ b86D8		// If no key pressed, skip key pressed processing
        CMP #$4B		// 'K' key ?
        BEQ b86C6		// go forward and through door
        CMP #$49		// 'I' pressed ?
        BEQ b86C9		// go forward
        CMP #$4C		// 'L' pressed ?
        BEQ b86D2		// turn right
        CMP #$4A		// 'J' pressed ?
        BEQ b86CF		// turn left
        CMP #$53		// 'S' pressed ?
        BEQ b86CC		// cast spell
        CMP #$50		// 'P' key pressed ? Enter PAUSE mode 
        BEQ b86D5
        CMP #$31		// < '1' pressed ? 
        BCC b869E		// loop on keyboard read when in maze
        CMP #$34		// >= '4' pressed .
        BCS b869E		// loop on keyboard read when in maze
        JMP jA263		// display character data sheet

b86C6   JMP j878E		// go forward and through door

b86C9   JMP j87A4		// go forward

b86CC   JMP j8A02		// cast spell
	
b86CF   JMP j8780		// turn left

b86D2   JMP j876D		// turn right

b86D5   JMP j8968		// Enter PAUSE mode

// Lecture du joystick
b86D8   LDA $DC00    	// Load CIA1 : Data Port Register A
        AND #$1F		// Mask to keep joystick bits
        CMP #$1E		// "up" switch is activated ?
        BEQ b86C9		// go forward
        CMP #$1B		// "left" switch is activated ?
        BEQ b86CF		// turn left
        CMP #$17		// "right" switch is activated ?
        BEQ b86D2		// turn right
        CMP #$0F		// fire button is pressed ?
        BEQ b86C6		// go forward and through door
        
// Increment counters so that the code after is executed once every 4.86 seconds
// (nearly 4783506) cpu cycles
		INC a7021		// increment first main loop counter
        BNE b872B		// if no overflow, loop on keyboard read
        INC a7012		// increment second main loop counter
        BNE b872B		// if no overflow, loop on keyboard read
   
// Look for wandering monsters    
		LDA $D41B    	// load random value between 0..31
        AND #$1F
        CMP #$01
        BCS b8707		// is value > 0 ?
        LDA a80			// Flag qui empeche un monstre errant ?
        BNE b8707
        JMP j94C5		// Random monster encounter

// Execute some code here half the time (light decline and characters healing)
// (nearly every 9.7 seconds, =9566743 cpu cycles)
b8707   INC a7022		// execute some code here half the time
        LDA a7022		// (value at $7022 flip between 0 and 1)
        CMP #$01
        BEQ b872B		// return to maze main loop
        LDA #$00		
        STA a7022
		
        LDA a81			// Load light counter
        BEQ b872E		// No light ? skip light decline and gong
        CMP #$F0		// Does the team has a staff of light ?
        BCS b872E		// if true, skip light decline and gong
        DEC a81			// decrement light counter
        BNE b872E		// if light is still on, skip gong
        JSR s8846		// Play gong signal
        JSR s8DB1		// Draw 3D view content
        JMP b872E

b872B   JMP b869E		// loop on keyboard read when in maze

// Heal characters holding an 'Amulet of Healing'
b872E   LDA #$00
        STA a7A			// Reset 'healing done' flag (non null when at least 1 character is healed)
        STA a3B			// let ($3B).w = $0800 (character data pointer)
        LDA #$08
        STA a3C
b8738   LDY #$00		// Load first char of first character name
        LDA (p3B),Y
        CMP #$24		// Empty slot ?
        BEQ b875B
        LDY #$1C		// If not, load magical item of character
        LDA (p3B),Y
        CMP #$03		// Is it an Amulet of healing ?
        BCC b875B		
        LDY #$13		// If true, load character constitution
        LDA (p3B),Y
        LDY #$1D		// Compare to character condition
        CMP (p3B),Y
        BEQ b875B		
        LDA (p3B),Y		// If not equal, reload character condition in A
        CLC 
        ADC #$01		// Increment condition
        STA (p3B),Y
        INC a7A			// Increment number of characters healed
b875B   INC a3C			// Let ($3b).w point to next character data
        LDA a3C			// All character slots processed ?
        CMP #$0B
        BNE b8738		// If not, process next character
        LDA a7A			// Have some character been healed ?
        BEQ b876A		// If not, return to maze main loop
        JSR sA0DF		// Redraw 3 stats lines of characters in maze view footer
b876A   JMP b869E		// loop on keyboard read when in maze

/////////////
// turn right
/////////////
j876D   CLC 
        LDA a65			// Load orientation (0=NORTH, 1=EAST)
        ADC #$01		// Increment orientation (in 0..3)
        CMP #$04
        BNE b8778
        LDA #$00
b8778   STA a65			
        JSR s8DB1		// Draw 3D view content
        JMP b869E		// loop on keyboard read when in maze
	
////////////
// turn left
////////////
j8780   LDA a65			// Load orientation (0=NORTH, 1=EAST)
        SEC 			// Decrement orientation (in 0..3)
        SBC #$01
        CMP #$FF
        BNE b8778
        LDA #$03
        JMP b8778		// loop on keyboard read

//////////////////////////////
// go forward and through door
//////////////////////////////
j878E   LDA a703D		// Is there a front wall ?
        BEQ b87A9		// If no, move forward
        CMP #$02		// Type 1 wall (door) ?
        BNE b879D
j8797   JSR s8807		// Play specific sound
        JMP b87A9		// and move forward
b879D   CMP #$03		// Type 3 door ?
        BNE b87F5		// If not, collide
        JMP j8797		// else Play specific sound and move forward

/////////////
// go forward
/////////////
j87A4   LDA a703D		// Is there a front door ?
        BNE b87F5		// if true, collide
b87A9   LDA a83			// is there a message in windows ?
        BEQ b87B4
        LDA #$00		// if so, reset flag,
        STA a83
        JSR sA347		// Reset message window and cursor
		
b87B4   LDA a65			// Load orientation (0=NORTH, 1=EAST)
        CMP #$01		// Facing east ?
        BEQ b87D2
        CMP #$02		// Facing south ?
        BEQ b87E2
        CMP #$03		// Facing west
        BEQ b87E7
		
        INC a48			// Move 1 space north
j87C4   LDA a48
        STA a63
        JSR s8F8F
        LDA a63
        STA a48			// Update YPos
        JMP j87EC

b87D2   INC a62			// move 1 space east
j87D4   LDA a62
        STA a64
        JSR s8E7E
        LDA a64
        STA a62
        JMP j87EC

b87E2   DEC a48			// move 1 space south
        JMP j87C4

b87E7   DEC a62			// move 1 space west
        JMP j87D4

j87EC   JSR s8DB1		// Draw 3D view content
        JSR s8894
        JMP b869E		// loop on keyboard read when in maze

// Hurting a wall...
// Draw collision and play sound
b87F5   JSR s884F		// Draw a star when hurting wall
        LDY #$82
        LDA #$47
        LDX #$05
        JSR s8810		// Play sound
        JSR s8870		// Clear a region of 3D covering the hurting star
        JMP b869E		// loop on keyboard read when in maze

//////////////////////////////////////////////
// Play a sound (used when going through door)
//////////////////////////////////////////////
s8807   LDA #$80
        LDX #$04
        LDY #$14
        JMP s8810		// Play sound

/////////////////////
// Play a sound
//
// Input parameters :
// X = MSB of frequency
// A = LSB of frequency
// Y = duration (1=short, $FF & $0=long)
/////////////////////
s8810   STX $D401   // Voice 1: Frequency Control - High-Byte
        STA $D400   // Voice 1: Frequency Control - Low-Byte
        STY a73		// save duration
        LDA #$8F	
        STA $D418   // Select Filter Mode and Volume (Chan 3 off, no filter, Max volume=15)
        LDA #$09	
        STA $D405   // Voice 1: Attack / Decay Cycle Control (Attack=0, Decay=9)
        LDA #$00
        STA $D406   // Voice 1: Sustain / Release Cycle Control (No Sustain, No Release)
        LDA #$21
        STA $D404   // Voice 1: Control Register (Set SAW & set GATE) -> start sound play
		
// a delay loop proportional to duration parameter
        LDX #$00
        LDY #$00
b8830   INX 		
        BNE b8830
        INY 
        CPY a73
        BNE b8830
		
        LDA #$00	// turn sound off in voice 1
        STA $D400   // Voice 1: Frequency Control - Low-Byte
        STA $D401   // Voice 1: Frequency Control - High-Byte
        LDA #$20
        STA $D404   // Voice 1: Control Register (Set SAW & clear GATE)
        RTS 

///////////////////////////////
// Play a gong signal 
// (kind of bell by the way...)
///////////////////////////////
s8846   LDX #$22
        LDA #$86
        LDY #$00
        JMP s8810			// Play sound

////////////////////////////////
// Draw a star when hurting wall
////////////////////////////////
s884F   LDA #$00
        STA a3D
b8853   LDX a3D
        LDY fA56D,X
        LDA fA575,X
        JSR s9359			// Set pen position from Y,A
        LDY fA57D,X
        LDA fA585,X
        JSR s9315			// Draw line
        INC a3D
        LDA a3D
        CMP #$08
        BNE b8853
        RTS 

///////////////////////////////////////////////////
// Clear a region of 3D covering the hurting star :
// Screen blocks (8,8)->(11,11) (32x32 pixels)
///////////////////////////////////////////////////
s8870   LDX #$08			// Start filling block at row 12
b8872   LDA fA4E8,X			// load MSB of bitmap address offset (relative to $20) of first 8x8 block at line X
        CLC 
        ADC #$20
        STA aFC
        LDA f5000,X			// load LSB of bitmap address offset of first 8x8 block at screen row X
        STA aFB
        BCC b8883			// ?? once again carry cannot be set here...
        INC aFC
b8883   LDY #$40			// Start filling block at column 8
b8885   LDA #$00
        STA (pFB),Y
        INY 
        CPY #$60			// Stop filling block at column 12
        BNE b8885
        INX 
        CPX #$0C			// Stop filling block at row 12
        BNE b8872
        RTS 

/////////////////////////////////////////////////////////
// Test triggers for square at current position
// Trigger structure follow this format
// $70 bytes grouped by pair
// each pair is coordinate (north, west)
// 4 first pairs are reserved for special triggers :
// $00-$01 is for upstairs
// $02-$03 is for downstairs
// $04-$05 is for clue
// $06-$07 is for hole in floor
// All other pairs are monsters locations
// Note that monster number is the pair index AND with $0F
//////////////////////////////////////////////////////////
s8894   LDA a84			// Load current maze floor
        CLC 
        ADC #$C0		// Let ($66).w point to squares triggers of current level
        STA a67
        LDA #$00
        STA a66
        LDX #$00		// initialize trigger index to 0
        LDY #$00		// initialize byte offset in triggers structure
b88A3   LDA (p66),Y
        CMP a48			// Compare YPos
        BNE b88BC		// if not equal, skip this trigger
        INY 
        LDA (p66),Y
        CMP a62			// Compare to XPos
        BNE b88BD		// if not equal, skip this trigger
        CPX #$04		// trigger 0..3 ?
        BCC b88C4		// if so, it's not a monster. Branch to special trigger
        STY a66			// update ($66).w to point to next trigger
        TXA 			// load trigger index in ACC
        AND #$0F		// get monster ID ($0..$F) in ACC
        JMP j94CA		// start monster encounter

b88BC   INY 			// jump to next trigger
b88BD   INY 
        INX 			// increment trigger index
        CPY #$00		// 256 bytes read ?
        BNE b88A3		// if not, load next pair
        RTS 

// Load address of message to display when the trigger fires.
// $A43D+offset stores LSB of address
// $B4E1+offset stores MSB of address
// where offset=0 for upstairs, offset=1 for downstairs
// offset=2 for clue of level 0, offset=3 for hole of level 0
// offset=4 for clue of level 1, offset=5 for hole of level 1
// offset=6 for clue of level 2, offset=7 for hole of level 2
// offset=8 for clue of level 3, offset=9 for hole of level 3
// offset=10 for clue of level 4, offset=11 for hole of level 4
// Note that MSB is 0 for all hole triggers and no message is displayed (but party falls 1 level down)
b88C4   STX a87			// store trigger index at $87
        CPX #$02		// is it an upstairs or downstairs trigger ?
        BCC b88D1		// if so, addresses of messages to display are always the same
        LDA a84			// if not, add current maze floor << 1 to up/downstairs byte
        ASL 			
        CLC 
        ADC a87			// $87 is now in range $0..$B (bit 0 for trigger type (0=clue, 1=hole=) and upper bits for level)
        TAX 
b88D1   LDA fA43D,X		// load LSB of message to display address in ($3B).w
        STA a3B
        LDA fB4E1,X		// load MSB of message to display address in ($3B).w
        BNE b88DE		// if MSB is zero, assume it's an hole :
        JMP j8962		// increment level (1 floor downstair) and recompute wandering monster flag

b88DE   STA a3C			
        JSR sA347		// Reset message window and cursor
        JSR s8846		// Play gong signal
        LDA #$06		// row number 6
        STA a4A
        LDA #$15		// column number 21
        STA a49

// Output message stored at ($3B).w and delimited by $FF at position (21,6).
// If cursor reaches column 39, return to next window line
// Messages start addresses are : 
// $BA00 : " THERE ARE STAIRS  HERE, GOING UP.   TAKE THEM (Y-N)?"
// $BA36 : " THERE ARE STAIRS  HERE, GOING DOWN. TAKE THEM (Y-N)?"
// $BA6C : " A VOICE SAYS:     I HAVE LAID 3     CLUES TO BRING    YOU TO ME..."
// $BAB0 : " A CLUE...         I AM DESTINY      PERSONIFIED"
// $BB17 : " A CLUE...         MY NAME IS IN     THE LOWER 4 MAPS"
// $BAE1 : " A VOICE SAYS:     TOWARD THE NE     WARE THE STOP     ELSE MAGIC TRIES  TO MAKE YOU DROP "
// $BB72 : " A VOICE SAYS:     ANSWER THIS       RIDDLE TO PASS--   I LIE AHEAD       FOR EVERY MAN     THAT IS WITHIN    THE MASTER PLAN    I AM "
// $AA00 : "
        LDY #$00
j88F0   LDA (p3B),Y
        CMP #$FF
        BEQ b890D
        JSR s9E94		// Output char in AC
        INY 
        BNE b88FE
        INC a3C
b88FE   LDA a49
        CMP #$27		// does cursor has reached end of message window line ?
        BCC b890A
        INC a4A			// if so, go next row
        LDA #$15		// and column 21 (first column of window)
        STA a49
b890A   JMP j88F0

b890D   LDA a87			// reload trigger index
        CMP #$02		// if trigger is upstairs/downstairs
        BCS b893E
b8913   JSR s9E8E		// wait for a keyboard input
        CMP #$59		// 'Y' key pressed ?
        BEQ b8921
        CMP #$4E		// 'N' key pressed ?
        BNE b8913
        JMP j893A

// Key 'Y' pressed 
b8921   LDA a87			// is it an upstairs trigger ?
        BNE b8932
        DEC a84			// If so, decrement current maze floor
        LDA a84			// Was it level 0 ?
        CMP #$FF
        BNE b8934
        PLA 			// 
        PLA 
        JMP j897F		// Come back to base camp

b8932   INC a84			// Increment current maze floor
b8934   JSR s8DB1		// Draw 3D view content
        JSR s9BEA		// Deactivate wandering monstering according to party level and maze floor number.
j893A   JSR sA347		// Reset message window and cursor
        RTS 

b893E   INC a83			// set message in window flag
        LDA a84			// Load current maze floor
        CMP #$04
        BNE b8967
        JSR s9FEE		// Lit 9 caracteres  depuis le clavier
        LDX #$00
b894B   LDA f0B00,X
        CMP fA428,X
        BNE b895C
        INX 
        CPX #$04
        BNE b894B
        JSR sA347		// Reset message window and cursor
        RTS 

b895C   DEC a62			// go one space WEST
        JSR s8DB1		// Draw 3D view content
        RTS 	

j8962   INC a84			// increment level (1 floor downstair)
        JSR s9BEA		// Deactivate wandering monstering according to party level and maze floor number.
b8967   RTS 

////////////////////////////////////////////////
// Entre en mode PAUSE
//
// Fait clignoter le logo MAZE MASTER
// et boucle tant qu'aucune touche n'est pressée
////////////////////////////////////////////////
j8968   JSR $FFE4    	// read keyboard    
        BNE b897C		// key pressed ? exite pause mode
        JSR s9C5B		// WHITE logo on RED background
        JSR s9C62		// waiting loop
        JSR s9C29		// RED logo on WHITE background
        JSR s9C62		// waiting loop
        JMP j8968

b897C   JMP b869E		// loop on keyboard read when in maze

//////////////////////////////////////
// Part has come back to base camp
//////////////////////////////////////
j897F   LDA #$00		// load first character data structure in ($3B).w
        STA a3B
        LDA #$08
        STA a3C
b8987   LDY #$00		// is there a character in this slot ?
        LDA (p3B),Y		
        CMP #$24		// if not, return to game welcome screen
        BEQ b89FF
        LDY #$1F		// load MSB of character tmp experience
        LDA (p3B),Y
        LSR 			// divide by 4
        LSR 
        STA a73			// store tmp experience / 1024 at $73
        LDY #$18		// load MSB of character experience
        LDA (p3B),Y
        LSR 			// divide by 4
        LSR 
        STA a45			// store experience / 1024 at $45
        LDY #$1F		// copy MSB of tmp experience into MSB of experience
        LDA (p3B),Y
        LDY #$18
        STA (p3B),Y
        LDY #$1E		// copy LSB of tmp experience into LSB of experience
        LDA (p3B),Y
        LDY #$17
        STA (p3B),Y
        LDA a73			// compute (tmp experience / 1024) - (experience / 1024)
        SEC 
        SBC a45
        CMP #$00		// if values ares the same, character gained no level...
        BEQ b89F7		// and then, process next character
        TAX 
b89B9   LDA $D41B    	// else load random value between 1..4
        AND #$03
        CLC 
        ADC #$01
        LDY #$13		// and add it to character constitution
        CLC 
        ADC (p3B),Y
        BCC b89CA		// if new value overflows (>255) then set it to 255
        LDA #$FF
b89CA   STA (p3B),Y
b89CC   LDA $D41B    	// load random value between 0..2
        AND #$03
        CMP #$03
        BEQ b89CC
        CLC 
        ADC #$10		// add 16 to it to get value in range 16..18
        STA a73			// save at $73
        LDY #$00
b89DC   INY 
        BNE b89DC
        LDY a73
        LDA $D41B    	// load random value between 1..2
        AND #$01
        CLC 
        ADC #$01
        CLC 
        ADC (p3B),Y
        CMP #$13		// if the value overflows (>18) then set it to 18
        BCC b89F2
        LDA #$12
b89F2   STA (p3B),Y
        DEX 
        BNE b89B9
		
b89F7   INC a3C			// process next character
        LDA a3C
        CMP #$0B		// last character processed ?
        BNE b8987		// if not, loop on character processing
b89FF   JMP j8137		// return to game welcome screen

///////////////////////////////
// Cast spell when not in fight
///////////////////////////////
j8A02   JSR sA347		// Reset message window and cursor
// Ouput screen codes 20,11,18,24,20,12,15,15,24,0C,0A,1C,1D,27,24,01,49,03,24,4A,00,2A,17,18,17,0E at (22,6)
// that matches chars "WHO WILL CAST? 1-3 (0:NONE)"
        LDX #$00
b8A07   LDA fA7D5,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$1B		// Message written ?
        BEQ b8A1E		// If true, read keyboard
        CPX #$0E		// else, test if 14 chars written
        BNE b8A07		// if not, keep on writting on same line
        JSR sA36D		// One line return in message window and reset X
        LDX #$0E		// restore X
        JMP b8A07		// write the end of message on new line

b8A1E   JSR s9E8E		// Lecture bloquante touche clavier
        SEC 
        SBC #$30
        CMP #$04
        BCS b8A1E		// Si touche >= 4, on boucle sur la lecture clavier
        CMP #$00		// Touche '0' pressée ?
        BNE b8A32		// si oui ?
b8A2C   JSR sA347		// Reset message window and cursor
        JMP b869E		// loop on keyboard read when in maze

b8A32   CLC 			// Is there a character in selected slot ?
        ADC #$07
        STA a3C
        LDY #$00
        STY a3B
        LDA (p3B),Y
        CMP #$24
        BEQ b8A1E		// If slot is empty, loop on keyboard read
        JSR sA36B		// Two line returns in message window and reset X
		
// Ouput screen codes 1C,19,0E,15,15,24,17,1E,16,0B,0E,1B,2A,24 (22,9)
// that matches chars "SPELL NUMBER: "
b8A44   LDA fBC88,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0E
        BNE b8A44
		
        JSR s9FFC		// Lit 3 caracteres depuis le clavier
        JSR s9F9D		// Convert a decimal value from input buffer into ($75).w
        LDA a75			// Read entered value
        BEQ b8A2C		// If value is invalid, clear window and return to main game loop
        CMP #$13		// if value is > 18, clear window and return to main game loop
        BCS b8A2C
        TAX 	
        STX a47			// save spell number in $47
        LDA fA3C0,X		// table indexed with spell number, storing zero value for combat spells
        BNE b8A81		// if combat spell, display warning message in window and return to main loop
		
        LDX #$00
j8A67   INC a4A			// next row
        LDA #$16		// column 22
        STA a49
        INC a83			// set message in window flag
		
// Ouput screen codes 0F,18,1B,24,0C,18,16,0B,0A,1D,24,18,17,15,22 at (22,10)
// that matches chars "FOR COMBAT ONLY"
// Or, ouput screen codes 15,0A,0C,14,24,1C,19,0E,15,15,24,19,1D,1C,1A at (22,10)
// that matches chars "LACK SPELL PTS"
b8A6F   LDA fA7F0,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0F		// compare char position for first message
        BEQ b8A7E		
        CPX #$1D		// compare char position for second message
        BNE b8A6F
b8A7E   JMP b869E		// loop on keyboard read when in maze

b8A81   LDX a47			// load spell number
        LDA fA3D3,X		// load required spell points for this spell
        STA a46			// store required spell points
        LDY #$21		// load character spell points
        LDA (p3B),Y
        CMP a46			// do character have enough spell point ?
        BCS b8A95		// if true, cast spell
        LDX #$0F		// else update char index to display
        JMP j8A67		// a warning message

b8A95   SEC 			// remove used spell points
        SBC a46
        STA (p3B),Y		// and update character spell points
        JSR sA347		// Reset message window and cursor
        LDA a47
        CMP #$03		// Spell 3 ? (HEAL)
        BEQ b8AD0
        CMP #$04		// Spell 4 ? (ORIENT)
        BEQ b8AE5
        CMP #$07		// Spell 7 ? (RESTORE)
        BEQ b8AD3
        CMP #$08		// Spell 8 ? (LIGHT)
        BEQ b8ACA
        CMP #$0B		// Spell 11 ? (REGENERATE)
        BEQ b8AD6
        CMP #$0C		// Spell 12 ? (CAT EYES)
        BEQ b8ACD
        CMP #$0E		// Spell 14 ? (PHASE WALL)
        BEQ b8AD9
        CMP #$10		// Spell 15 ? (TELEPORT)
        BEQ b8ADC
        CMP #$0F		// Spell 15 ? (SHADOW SHIELD)
        BEQ b8ADF
        CMP #$12		// Spell 18 ? (RENEWAL)
        BEQ b8AE2
        JMP b869E		// loop on keyboard read when in maze

b8ACA   JMP j8B82		// Cast LIGHT

b8ACD   JMP j8B92		// Cast CAT EYES

b8AD0   JMP j8BA2		// Cast HEAL

b8AD3   JMP j8BCD		// Cast RESTORE

b8AD6   JMP j8BD5		// Cast REGENERATE

b8AD9   JMP j8C37		// Cast PHASE WALL

b8ADC   JMP j8C56		// Cast TELEPORT

b8ADF   JMP j8C4B		// Cast SHADOW SHIELD

b8AE2   JMP j8C14		// Cast RENEWAL

///////////////////////////////////////////////////////////////
// Cast spell 4 : orient
// This spell will inform the party of its location in relation
// to the exit stairway from the maze, on level 0, as well as 
// telling the current direction the party faces.
///////////////////////////////////////////////////////////////
b8AE5   LDX #$00		// reset MSB of word to display	
        STX a76

// Ouput screen codes $22,$18,$1E,$24,$0A,$1B,$0E,$24
// that matches chars "YOU ARE "
b8AE9   LDA fBC96,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$08
        BNE b8AE9
		
        LDA a48			// Load YPos
        STA a75			// Store YPos in LSB of word to display
        JSR sA1ED		// Display word value stored in ($75).w
		
// Ouput screen codes $24,$1C,$19,$0A,$0C,$0E,$1C,
// that matches chars " SPACES"
        LDX #$08
b8AFD   LDA fBC96,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0F
        BNE b8AFD
		
        JSR sA36D		// One line return in message window and reset X

// Ouput screen codes $17,$18,$1B,$1D,$11,$25,$24
// that matches chars "NORTH, "		
        LDX #$0F
b8B0D   LDA fBC96,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$16
        BNE b8B0D

        LDA a62			// Load XPos
        STA a75			// Store XPos in LSB of word to display
        JSR sA1ED		// Display word value stored in ($75).w
		
// Ouput screen codes $24,$1C,$19,$0A,$0C,$0E,$1C
// that matches chars " SPACES"
        LDX #$16
b8B21   LDA fBC96,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$1D
        BNE b8B21
		
        JSR sA36D		// One line return in message window and reset X
        
// Ouput screen codes $0E,$0A,$1C,$1D,$25,$24,$0A,$17,$0D,$24
// that matches chars "EAST, AND "
		LDX #$1D
b8B31   LDA fBC96,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$27
        BNE b8B31
		
        LDA a84			// Load level (current floor)
        JSR s9E94		// Output char in AC
b8B41   INC a4A			// next row
        LDA #$16		// column 22
        STA a49
// Ouput screen codes $15,$0E,$1F,$0E,$15,$1C,$24,$0B,$0E,$15,$18,$20,$24,$1D,$11,$0E
// that matches chars "LEVELS BELOW THE"
// Ouput screen codes $0E,$17,$1D,$1B,$22,$24,$1C,$1D,$0A,$12,$1B,$1C,$25
// that matches chars "ENTRY STAIRS,"
j8B47   LDA fBC96,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$44
        BEQ b8B59
        CPX #$37
        BEQ b8B41
        JMP j8B47

b8B59   JSR sA36D		// One line return in message window and reset X

// Ouput screen codes $17,$18,$20,$24,$0F,$0A,$0C,$12,$17,$10,$24
// that matches chars "NOW FACING "
        LDX #$44
b8B5E   LDA fBC96,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$4F
        BNE b8B5E
		
        LDX a65			// Load orientation (0=NORTH, 1=EAST)
        LDA fA424,X   	// Load text offset for direction NORTH = 0, EAST = 5, SOUTH = 10, WEST = 15 
        TAX 
        LDY #$00
b8B71   LDA fBCE5,X		// Load direction text
        JSR s9E94		// Output char in AC
        INX 
        INY 
        CPY #$05
        BNE b8B71
        INC a83			// set message in window flag
        JMP b869E		// loop on keyboard read when in maze

/////////////////////////////////////////////////////////////
// Cast spell 8 : light
// This spell allows the party to see 4 spaces ahead 
// (extended distance), as well as detect secret doors. 
// The effects of this spell last at least 15 minutes in real
// time, and a gong will signal termination of spell.
/////////////////////////////////////////////////////////////
j8B82   LDA a81			// Load light counter
f8B84   CMP #$F0		// Do the party have a staff of light ?
        BCS b8B8C		// If so, don't modify light counter
        LDA #$64		// Set light counter to $64
        STA a81
b8B8C   JSR s8DB1		// Draw 3D view content
        JMP b869E		// loop on keyboard read when in maze

/////////////////////////////////////////////////////////
// Cast spell 12 : cat eyes
// This spell is similar to Spell 8, for double duration 
//(at least 30 minutes of real time).
/////////////////////////////////////////////////////////
j8B92   LDA a81			// Load light counter
        CMP #$F0		// Do the party have a staff of light ?
        BCS b8B9C		// If so, don't modify light counter
        LDA #$C8		// Set light counter to $C8
        STA a81
b8B9C   JSR s8DB1		// Draw 3D view content
        JMP b869E		// loop on keyboard read when in maze

/////////////////////////////////////////////////////////////////
// Cast spell 3 : heal
// This spell will heal 1-32 points of the spellcaster’s own CND.
/////////////////////////////////////////////////////////////////
j8BA2   LDA $D41B    ;Oscillator 3 Output
        AND #$1F
        CLC 
        ADC #$01
        STA a45
        LDY #$1D
        LDA (p3B),Y
        CLC 
        ADC a45
        BCC b8BB7
        LDA #$FF
b8BB7   STA a45
        LDY #$13
        LDA (p3B),Y
        CMP a45
        BCC b8BC3
        LDA a45
b8BC3   LDY #$1D
        STA (p3B),Y
        JSR sA0DF		// Redraw 3 stats lines of characters in maze view footer
        JMP b869E		// loop on keyboard read when in maze

/////////////////////////////////////////////////////////////////////
// Cast spell 7 : restore
// This spell will heal the CND of every party member by 1-16 points.
/////////////////////////////////////////////////////////////////////
j8BCD   LDA $D41B    ;Oscillator 3 Output
        AND #$0F
        JMP j8BDA

//////////////////////////////////////////////////////////////////////
// Cast spell 11 : regenerate
// This spell is similar to spell 7, except that it heals 1-32 points.
//////////////////////////////////////////////////////////////////////
j8BD5   LDA $D41B    ;Oscillator 3 Output
        AND #$1F
j8BDA   CLC 
        ADC #$01
        STA a46
        LDA #$08
        STA a3C
b8BE3   LDY #$00
        LDA (p3B),Y
        CMP #$24
        BEQ b8C0E
        LDY #$1D
        LDA (p3B),Y
        CLC 
        ADC a46
        BCC b8BF6
        LDA #$FF
b8BF6   STA a45
        LDY #$13
        LDA (p3B),Y
        CMP a45
        BCC b8C02
        LDA a45
b8C02   LDY #$1D
        STA (p3B),Y
        INC a3C
        LDA a3C
        CMP #$0B
        BNE b8BE3
b8C0E   JSR sA0DF		// Redraw 3 stats lines of characters in maze view footer
        JMP b869E		// loop on keyboard read when in maze

//////////////////////////
// Cast spell 18 : renewal
//////////////////////////
j8C14   LDA #$08
        STA a3C
        LDA #$00
        STA a3B
b8C1C   LDY #$00
        LDA (p3B),Y
        CMP #$24
        BEQ b8C34
        LDY #$13
        LDA (p3B),Y
        LDY #$1D
        STA (p3B),Y
        INC a3C
        LDA a3C
        CMP #$0B
        BNE b8C1C
b8C34   JMP b8C0E

/////////////////////////////
// Cast spell 14 : phase wall
/////////////////////////////
j8C37   LDA a84			// Load level (current floor)
        CMP #$04
        BNE b8C40
        JMP b869E		// loop on keyboard read when in maze

b8C40   LDA #$00
        STA a703D		// clear facing wall flag
        JSR s9045
        JMP b869E		// loop on keyboard read when in maze

////////////////////////////////
// Cast spell 15 : shadow shield
////////////////////////////////
j8C4B   LDA #$02
        STA a704E
        JSR sA0DF		// Redraw 3 stats lines of characters in maze view footer
        JMP b869E		// loop on keyboard read when in maze

///////////////////////////
// Cast spell 16 : teleport
///////////////////////////
// Ouput screen codes 1D,0E,15,0E,19,18,1B,1D,26,26,26,15,0E,1F,0E,15,1C at (22,22)
// that matches chars "TELEPORT..."
j8C56   LDX #$00
b8C58   LDA fBCF9,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0B
        BNE b8C58
		
// Ouput screen codes 15,0E,1F,0E,15,1C,24,0D,18,20,17,2A,24 at (22,24)
// that matches chars "LEVELS DOWN: "
        JSR sA36B		// Two line returns in message window and reset X
        LDX #$0B
b8C68   LDA fBCF9,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$18
        BNE b8C68
		
j8C73   JSR s8D28		// ask for a numeric value between (0..40) <-> (-20..+20) and load in ACC
        CMP #$14		// if value equal 20 (user selected zero)
        BEQ b8CA9		// skip level modification
        BCC b8C99		// negative 'down levels' ? go upstairs !
		
// go downstairs
        SEC 			
        SBC #$14		// get number of levels down in ACC
        CLC 
        ADC a84			// and add it to current level
        CMP #$05		// ensure that we don't teleport below last level
        BCC b8C8C		
        JSR s8DA5		// else wait for joystick released
        JMP j8C73		// and loop on numeric value request, initialized at +0

b8C8C   STA a84			// store level (current floor)
        CMP #$04		// are we trying to teleport to last floor (4) ?
        BNE b8CA9
        LDA #$00		// if so, 'bounce' party to first level (floor 0)
        STA a84			
        JMP b8CA9		// now request north offset value

// go upstairs
b8C99   LDA #$14		// get number of levels up in ACC
        SEC 
        SBC a47
        STA a47
        LDA a84			// load level (current floor)
        SEC 
        SBC a47			// subtract number of levels up from current level
        BCC j8C73		// if we try to teleport above level 0, loop on numeric value request
        STA a84			// store new level
		
// request north offset value
b8CA9   LDA a48			// Load party YPos
        STA a82			// Save it at $82 (tmp YPos)
        JSR s8DA5		// wait for joystick released
        JSR sA36D		// One line return in message window and reset X

// Ouput screen codes 17,18,1B,1D,11,2A,24 at (22,25)
// that matches chars "NORTH: "
        LDX #$18
b8CB5   LDA fBCF9,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$1F
        BNE b8CB5

        JSR s8CF4		// Ask for a offset value and ensure new tmp YPos is in range (0..19)
        LDA a82			// Load new tmp YPos
        STA a48			// Update YPos
        JSR s8DA5		// wait for joystick released
		
// request east offset value		
        LDA a62			// Load XPos
        STA a82			// Save it at $82 (tmp XPos)
        JSR sA36D		// One line return in message window and reset X

// Ouput screen codes 0E,0A,1C,1D,2A,24 at (22,26)
// that matches chars "EAST: "
        LDX #$1F
b8CD3   LDA fBCF9,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$25
        BNE b8CD3
		
        JSR s8CF4		// Ask for a offset value and ensure new tmp XPos is in range (0..19)
        LDA a82			// Load new tmp XPos
        STA a62			// Update XPos
        JSR sA347		// Reset message window and cursor
        JSR s9BEA		// Deactivate wandering monsters according to party level and maze floor number.
        JSR s8DB1		// Draw 3D view content
        JSR s8894
        JMP b869E		// loop on keyboard read when in maze

s8CF4   JSR s8D28		// ask for a numeric value between (0..40) <-> (-20..+20)
        LDA a47			// load selected value (should be also in ACC)
        CMP #$14		// is value equal to 20 <-> +0 ?
        BEQ b8D11		// if so load unchanged value in ACC and return
        BCC b8D14		// if value is <20 <-> negative, substract from tmp YPos

// Add selected value to tmp YPos
        SEC 
        SBC #$14
        CLC 
        ADC a82
        CMP #$14		// is tmp YPos < 20 ?
        BCC b8D0F		// if so, update current YPos
        JSR s8DA5		// else, wait for joystick released
        JMP s8CF4		// loop on numeric value request

// Update YPos from ACC and return
b8D0F   STA a82
b8D11   LDA a82
        RTS 

// Substract selected value from tmp YPos
b8D14   LDA #$14		// compute value to subtract to tmp YPos
        SEC 
        SBC a47
        STA a47
        LDA a82
        SEC 
        SBC a47			// subtract value to tmp YPos
        BCS b8D0F		// if result is positive, update current YPos
        JSR s8DA5		// wait for joystick released
        JMP s8CF4		// loop on numeric value request

/////////////////////////////////////////////////////////////
// Display an initial value of 0, ranging (-20..+20)
// and that can be modifier either with joystick (left,right)
// or cursor key (left,right).
// Loop until value is validated by space or fire button.
// Return : selected value in ACC (0..40) and $47
/////////////////////////////////////////////////////////////
s8D28   LDA #$00		// set MSB of word value to display to zero
        STA a76
        LDA #$14		// initialize selected value to 20
        STA a47			
        LDA a49			// load current column number
        STA a87			// save it at $87
j8D34   LDA a47			// load selected value
        CMP #$14		// is value < 20 ?
        BCC b8D53		// if true, display negative value
        SEC 
        SBC #$14		// store value - 20 in LSB of ($75).w
        STA a75
        LDA #$4B		// load character '+'
// display sign and value in ($75).w
j8D41   JSR s9E94		// Output char in AC
        JSR sA1ED		// Display word value stored in ($75).w
        LDA #$24
        JSR s9E94		// Output char in AC
        LDA a87			// reload saved column number
        STA a49
        JMP j8D5F		// wait for value modification or validation, then return

// display negative value
// load LSB of value to display to (20-value) and load '-' character
b8D53   LDA #$14		// compute 20-selected value
        SEC 
        SBC a47			
        STA a75			// store result in LSB of ($75).w
        LDA #$49		// load '-' character
        JMP j8D41		// display '-' and value in ($75).w

// load input from joystick in port 2
j8D5F   LDA $DC00    	// Load CIA1: Data Port Register A
        AND #$1F		// Mask to keep joystick bits
        CMP #$17		// "right" switch is activated ?
        BEQ b8D87		// Increment value at $47 till a max of 40
        CMP #$1B		// "left" switch is activated ?
        BEQ b8D92		// Decrement value at $47 till a min of 0
        CMP #$0F		// fire button is pressed ?
        BNE b8D73		// if not, look for key pressed
        LDA a47			// load selected value
        RTS 

b8D73   JSR $FFE4    	// read keyboard     
        BEQ j8D5F		// if no key pressed, loop to joystick read
        CMP #$1D		// cursor right key ?
        BEQ b8D87		// Increment value at $47 till a max of 40
        CMP #$9D		// cursor left key ?
        BEQ b8D92		// Decrement value at $47 till a min of 0
        CMP #$20		// space key ?
        BNE j8D5F		// if not, loop to joystick read
        LDA a47			// load selected value
        RTS 

// Increment value at $47 till a max of 40
b8D87   LDA a47
        CMP #$28
        BEQ j8D5F
        INC a47
        JMP j8D9B		// wait for 358ms and loop on displaying current value

// Decrement value at $47 till a min of 0
b8D92   LDA a47
        BEQ j8D5F
        DEC a47
        JMP j8D9B		// wait for 358ms and loop on displaying current value

j8D9B   JSR s8DA1		// wait for 358ms
        JMP j8D34		// loop on displaying current value

// wait for 358ms and return
s8DA1   JSR s9C62		// waiting loop
        RTS 

/////////////////////////////
// wait for joystick released
/////////////////////////////
s8DA5   LDA $DC00    	// Load CIA1: Data Port Register A
        AND #$1F		// Mask to keep joystick bits
        CMP #$1F		// is there one joystick direction or button pressed ?
        BNE s8DA5		// if not, loop on joystick read
        JMP s8DA1		// else wait for 358ms and return

////////////////////////////
//	Draw 3D view content 
////////////////////////////
s8DB1   LDA a65			// Load orientation (0=NORTH, 1=EAST)
        BEQ b8DC6		// Facing NORTH ?
        CMP #$01
        BEQ b8DC0		// Facing EAST ?
        CMP #$02
        BEQ b8DC3		// Facing SOUTH ?
        JMP j8FA3		// Render WEST view

b8DC0   JMP j8F11		// Render EAST view

b8DC3   JMP j8E92		// Render SOUTH view

// Render 3D view when facing NORTH
//
// Level 0 is stored at $AA00-$AB90
// Level 1 is stored at $AC00-$AD90
// Level 2 is stored at $AE00-$AE90
// Level 3 is stored at $B000-$B190
// Level 4 is stored at $B200-$B390
b8DC6   LDA a48			// Load YPos
        STA a63			// Save in tmp YPos at $63
        LDA a62			// Load XPos
        STA a64			// Save in tmp XPos at $64
        LDA #$00		// Reset view depth counter (0..4)
        STA a3D	
// Following code will compute rendering values in $7033..$704B
// Wall ID = 0 : no wall
// Wall ID = 1 : wall
// Wall ID = 2 : door
// Wall ID = 3 : hidden
//
// $7033-$7037 : wall ID for left side walls at depth 0..4
// $7038-$703C : wall ID for right side walls at depth 0..4
// $703D-$7041 : wall ID for front walls at depth 0..4
// $7042-$7046 : wall ID for front walls at our left depth 0..4
// $7047-$704B : wall ID for front walls at our right depth 0..4
// Note : $703D contains directly facing wall type (0=None, 1=Wall, 2=Door)
//
// Each level stores 20*20=400 bytes, one per cell, ordered by row, 
// each with this bitfield meaning :
// bit 0-1 : north Wall ID
// bit 2-3 : south Wall ID
// bit 4-5 : east Wall ID
// bit 6-7 : west Wall ID

b8DD2   JSR s8DE3		// Get wall id in $7013..$7017 for current view depth ($3D)
        JSR s9024		// copy ($7013)..($7017) into $7033+($3D)..$7047+($3D)
        INC a3D			// increment view depth
        LDA a3D
        CMP #$05		// view depth of 5 reached ?
        BNE b8DD2		// if not compute wall ID for next view depth
        JMP s9045		// Once all wall id are set, perform wires rendering in view

s8DE3   JSR s8E1C		// load square at X=($64) Y=($63) and get bit fields in $7015(Front),$7014(Right),$7013(Left)
        
	LDA a7013		// load bits 6 & 7 (West side) of square definition
        BNE b8DFE		// If there is a wall on left, don't test front wall on our left
        DEC a64			// decrement tmp XPos
        JSR s8E7E		// Wrap XPos between (0..19)
        JSR s8E50		// load square at X=($64) Y=($63) and get bit fields in $7018(N),$7019(S),$701A(E),$701B(W)
        LDA a7018		// load bits 0 & 1 (North side)
        STA a7016		// store it at $7016
        INC a64			// increment tmp XPos
        JSR s8E7E		// Wrap XPos between (0..19)
		
b8DFE   LDA a7014		// load bits 4 & 5 (East side) of square definition
        BNE b8E16		// If there is a wall on right, don't test front wall on our right
        INC a64			// increment tmp XPos
        JSR s8E7E		// Wrap XPos between (0..19)
        JSR s8E50		// load square at X=($64) Y=($63) and get bit fields in $7018(N),$7019(S),$701A(E),$701B(W)
        LDA a7018		// load bits 0 & 1 (North side)
        STA a7017		// store it at $7017
        DEC a64			// decrement tmp XPos
        JSR s8E7E		// Wrap XPos between (0..19)
b8E16   INC a63			// increment tmp YPos
        JSR s8F8F		// Wrap YPos between (0..19)
        RTS 

// Load square at position X=($64) Y=($63)
// Get bit fields :
// %00000011 in $7015 (north wall)
// %00110000 in $7014 (east wall)
// %11000000 in $7013 (west wall)
s8E1C   LDX a63			// load tmp YPos
        LDA f5400,X		// load LSB of square offset for this YPos
        STA aFB			// store in LSB of ($FB).w
        LDA a84			// load level (current floor)
        ASL 			// multiply by 2
        CLC 
        ADC fB4EC,X		// add MSB of square offset for this YPos 
        STA aFC			// store in MSB of ($FB).w
        LDY a64			// load tmp XPos
        LDA (pFB),Y		// load square definition
// Store bits 0 & 1 at $7015
        STA a45			// store it at $45
        AND #$03		// keep 2 lowest bits
        STA a7015		// store it at $7015
// Store bits 4 & 5 at $7014
        JSR s8E47		// Shift ($45) two bits right and keep bits 0 & 1 in ACC
        JSR s8E47		// Shift ($45) two bits right and keep bits 0 & 1 in ACC
        STA a7014		// Store bits 4-5 of ($45) at $7014
// Store bits 6 & 7 at $7013
        JSR s8E47		// Shift ($45) two bits right and keep bits 0 & 1 in ACC
        STA a7013		// Store bits 6 & 7 of ($45) at $7013 
        RTS 

// Shift ($45) two bits right and keep bits 2 & 3 in ACC
s8E47   LDA a45
        LSR 
        LSR 
        STA a45
        AND #$03
        RTS 

// Load square at position X=($64) Y=($63)
// Get bit fields :
// %00000011 in $7018
// %00001100 in $7019
// %00110000 in $701A
// %11000000 in $701B
s8E50   LDX a63			// load tmp YPos
        LDA f5400,X		// load LSB of square offset for this YPos
        STA aFB			// store in LSB of ($FB).w
        LDA a84			// load level (current floor)
        ASL 			// multiply by 2
        CLC 
        ADC fB4EC,X		// add MSB of square offset for this YPos 
        STA aFC			// store in MSB of ($FB).w
        LDY a64			// load tmp XPos
        LDA (pFB),Y		// load square definition
        STA a45			// store it at $45
        AND #$03		// keep 2 lowest bits
        STA a7018		// store it at $7018
        JSR s8E47		// Shift ($45) two bits right and keep bits 2 & 3 in ACC
        STA a7019		// store it at $7019
        JSR s8E47		// Shift ($45) two bits right and keep bits 4 & 5 in ACC
        STA a701A		// store it at $701A
        JSR s8E47		// Shift ($45) two bits right and keep bits 6 & 7 in ACC
        STA a701B		// store it at $701B
        RTS 


// Wrap ($64) between (0..19)
// If value goes negative, assign 19
// If value exceed 19 negative, assign 0
s8E7E   LDA a64
        CMP #$FF
        BNE b8E89
        LDA #$13
        STA a64
b8E88   RTS 
b8E89   CMP #$14
        BNE b8E88
        LDA #$00
        STA a64
        RTS 

// Render 3D view when facing SOUTH 
j8E92   LDA a48			// Load YPos
        STA a63			// Save in tmp YPos at $63
        LDA a62			// Load XPos
        STA a64			// Save in tmp XPos at $64
        LDA #$00		// Reset view depth counter (0..4)
        STA a3D
		
b8E9E   JSR s8EAF		// Get wall id in $7013..$7017 for current view depth ($3D)
        JSR s9024		// copy ($7013)..($7017) into $7033+($3D)..$7047+($3D)
        INC a3D			// increment view depth
        LDA a3D
        CMP #$05		// view depth of 5 reached ?
        BNE b8E9E		// if not compute wall ID for next view depth
        JMP s9045		// Once all wall id are set, perform wires rendering in view

s8EAF   JSR s8EE8		// load square at X=($64) Y=($63) and get bit fields in $7015(Front),$7014(Right),$7013(Left)
        LDA a7014		// Load wall ID of right wall (west)
        BNE b8ECA		// If there is a wall on right, don't test front wall on our right
        DEC a64			// decrement tmp XPos
        JSR s8E7E		// Wrap XPos between (0..19)
        JSR s8E50		// load square at X=($64) Y=($63) and get bit fields in $7018(N),$7019(S),$701A(E),$701B(W)
        LDA a7019		// Load wall ID of south wall of this square
        STA a7017		// store this ID for right front wall
        INC a64			// increment tmp XPos
        JSR s8E7E		// Wrap XPos between (0..19)
b8ECA   LDA a7013		// Load wall ID of left wall (east)
        BNE b8EE2		// If there is a wall on left, don't test front wall on our left
        INC a64			// increment tmp XPos
        JSR s8E7E		// Wrap XPos between (0..19)
        JSR s8E50		// load square at X=($64) Y=($63) and get bit fields in $7018(N),$7019(S),$701A(E),$701B(W)
        LDA a7019		// Load wall ID of south wall of this square
        STA a7016		// store this ID for left front wall
        DEC a64			// decrement tmp XPos
        JSR s8E7E		// Wrap XPos between (0..19)
b8EE2   DEC a63			// decrement tmp YPos (next view depth)
        JSR s8F8F		// Wrap YPos between (0..19)
        RTS 

s8EE8   LDX a63			// load tmp YPos
        LDA f5400,X		// load LSB of square offset for this YPos
        STA aFB			// store in LSB of ($FB).w
        LDA a84			// load level (current floor)
        ASL 			// multiply by 2
        CLC 
        ADC fB4EC,X		// add MSB of square offset for this YPos 
        STA aFC			// store in MSB of ($FB).w
        LDY a64			// load tmp XPos
        LDA (pFB),Y		// load square definition
        STA a45
// Store bits 2 & 3 (South) at $7015 (Front)
        JSR s8E47
        STA a7015
// Store bits 4 & 5 (East) at $7013 (Left)
        JSR s8E47
        STA a7013
// Store bits 6 & 7 (West) at $7014 (Right)
        JSR s8E47
        STA a7014
        RTS 

// Render 3D view when facing EAST
j8F11   LDA a48			// Load YPos
        STA a63			// Save in tmp YPos at $63
        LDA a62			// Load XPos
        STA a64			// Save in tmp XPos at $64
        LDA #$00		// Reset view depth counter (0..4)
        STA a3D
		
b8F1D   JSR s8F2E		// Get wall id in $7013..$7017 for current view depth ($3D)
        JSR s9024		// copy ($7013)..($7017) into $7033+($3D)..$7047+($3D)
        INC a3D			// increment view depth
        LDA a3D
        CMP #$05		// view depth of 5 reached ?
        BNE b8F1D		// if not compute wall ID for next view depth
        JMP s9045		// Once all wall id are set, perform wires rendering in view

s8F2E   JSR s8F67		// load square at X=($64) Y=($63) and get bit fields in $7015(Front),$7014(Right),$7013(Left)
        LDA a7013		// Load wall ID of left wall (North)
        BNE b8F49		// If there is a wall on left, don't test front wall on our left
        INC a63			// increment tmp YPos
        JSR s8F8F		// Wrap YPos between (0..19)
        JSR s8E50		// load square at X=($64) Y=($63) and get bit fields in $7018(N),$7019(S),$701A(E),$701B(W)
        LDA a701A		// Load wall ID of east wall of this square
        STA a7016		// store this ID for left front wall
        DEC a63			// decrement tmp YPos
        JSR s8F8F		// Wrap YPos between (0..19)
b8F49   LDA a7014		// Load wall ID of right wall (South)
        BNE b8F61		// If there is a wall on right, don't test front wall on our right
        DEC a63			// decrement tmp YPos
        JSR s8F8F		// Wrap YPos between (0..19)
        JSR s8E50		// load square at X=($64) Y=($63) and get bit fields in $7018(N),$7019(S),$701A(E),$701B(W)
        LDA a701A		// Load wall ID of east wall of this square
        STA a7017		// store this ID for right front wall
        INC a63			// increment tmp YPos
        JSR s8F8F		// Wrap YPos between (0..19)
b8F61   INC a64			// increment tmp XPos (next view depth)
        JSR s8E7E		// Wrap XPos between (0..19)
        RTS 

s8F67   LDX a63			// load tmp YPos
        LDA f5400,X		// load LSB of square offset for this YPos
        STA aFB			// store in LSB of ($FB).w
        LDA a84			// load level (current floor)
        ASL 			// multiply by 2
        CLC 
        ADC fB4EC,X		// add MSB of square offset for this YPos 
        STA aFC			// store in MSB of ($FB).w
        LDY a64			// load tmp XPos
        LDA (pFB),Y		// load square definition
        STA a45
// Store bits 0 & 1 (North) at $7013 (Left)
        AND #$03
        STA a7013
// Store bits 2 & 3 (South) at $7013 (Right)
        JSR s8E47
        STA a7014
// Store bits 4 & 5 (East) at $7013 (Front)
        JSR s8E47
        STA a7015
        RTS 

// Wrap ($63) between (0..19)
// If value goes negative, assign 19
// If value exceed 19 negative, assign 0
s8F8F   LDA a63
        CMP #$FF
        BNE b8F9A
        LDA #$13
        STA a63
b8F99   RTS 
b8F9A   CMP #$14
        BNE b8F99
        LDA #$00
        STA a63
        RTS 

// Render 3D when facing WEST
j8FA3   LDA a48			// Load YPos
        STA a63			// Save in tmp YPos at $63
        LDA a62			// Load XPos
        STA a64			// Save in tmp XPos at $64
        LDA #$00		// Reset view depth counter (0..4)
        STA a3D

b8FAF   JSR s8FC0		// Get wall id in $7013..$7017 for current view depth ($3D)
        JSR s9024		// copy ($7013)..($7017) into $7033+($3D)..$7047+($3D)
        INC a3D			// increment view depth
        LDA a3D
        CMP #$05		// view depth of 5 reached ?
        BNE b8FAF		// if not compute wall ID for next view depth
        JMP s9045		// Once all wall id are set, perform wires rendering in view

s8FC0   JSR s8FF9		// load square at X=($64) Y=($63) and get bit fields in $7015(Front),$7014(Right),$7013(Left)
        LDA a7014		// Load wall ID of right wall (North)
        BNE b8FDB		// If there is a wall on right, don't test front wall on our right
        INC a63			// increment tmp YPos
        JSR s8F8F		// Wrap YPos between (0..19)
        JSR s8E50		// load square at X=($64) Y=($63) and get bit fields in $7018(N),$7019(S),$701A(E),$701B(W)
        LDA a701B		// Load wall ID of west wall of this square
        STA a7017		// store this ID for right front wall
        DEC a63			// decrement tmp YPos
        JSR s8F8F		// Wrap YPos between (0..19)
b8FDB   LDA a7013		// Load wall ID of left wall (South)
        BNE b8FF3		// If there is a wall on left, don't test front wall on our left
        DEC a63			// decrement tmp YPos
        JSR s8F8F		// Wrap YPos between (0..19)
        JSR s8E50		// load square at X=($64) Y=($63) and get bit fields in $7018(N),$7019(S),$701A(E),$701B(W)
        LDA a701B		/ Load wall ID of west wall of this square
        STA a7016		// store this ID for left front wall
        INC a63			// increment tmp YPos
        JSR s8F8F		// Wrap YPos between (0..19)
b8FF3   DEC a64			// decrement tmp XPos (next view depth)
        JSR s8E7E		// Wrap XPos between (0..19)
        RTS 

s8FF9   LDX a63			// load tmp YPos
        LDA f5400,X		// load LSB of square offset for this YPos
        STA aFB			// store in LSB of ($FB).w
        LDA a84			// load level (current floor)
        ASL 			// multiply by 2
        CLC 
        ADC fB4EC,X		// add MSB of square offset for this YPos
        STA aFC			// store in MSB of ($FB).w
        LDY a64			// load tmp XPos
        LDA (pFB),Y		// load square definition
        STA a45
// Store bits 0 & 1 (North) at $7014 (right)		
        AND #$03
        STA a7014
// Store bits 2 & 3 (South) at $7013 (Left)
        JSR s8E47
        STA a7013
// Store bits 6 & 7 (West) at $7015 (Front)
        JSR s8E47
        JSR s8E47
        STA a7015
        RTS 

// Copy wall ID of current view depth to rendering addresses. 
// Wireframe rendering uses wall ID stored at $7033..$704B
// ($7013) in $7033+($3D)
// ($7014) in $7038+($3D)
// ($7015) in $703D+($3D)
// ($7016) in $7042+($3D)
// ($7017) in $7047+($3D)
s9024   LDX a3D
        LDA a7013
        STA f7033,X
        LDA a7014
        STA f7038,X
        LDA a7016
        STA f7042,X
        LDA a7017
        STA f7047,X
        LDA a7015
        STA a703D,X
        RTS 

/////////////////////////////////////////
// Draw walls in 3D view
//
// input : wall ID stored at $7033..$704B
// for a max view depth of 5
/////////////////////////////////////////
s9045   LDA #$00			// Initialize view depth at 0
        STA a3D
        JSR s93A2			// Clear 3D view and draw border
b904C   JSR s9069			// Draw walls of current view depth
        LDX a3D
        LDA a703D,X			// Is there a wall in front of us at current depth ?
        BNE b9068			// if true, no more rendering is required, stop drawing and return
        INX 				// increment view depth
        CPX #$05			// max view depth of 5 reached ?
        BEQ b9068			// if true, stop rendering
        STX a3D				// update dpeth view variable
        CPX #$03			// At depth 3, check light presence
        BNE b904C			// else, keep on rendering
        LDA a81				// Load 'light' flag
        BEQ b9068			// if no light, stop rendering at view depth 3
        JMP b904C			// else, keep on rendering still depth 5

b9068   RTS 

// Draw wall on our left
s9069   LDX a3D				// Load current view depth (0..4)
        LDA f7033,X			// Is there a wall on left at current depth ?
        BEQ b90D5			// if no, skip drawing
// Coordinates of left wall vertices for all 5 depth :
// ($00,$9F) ($00,$00) ($0F,$0F) ($0F,$91)
// ($0F,$91) ($0F,$0F) ($28,$28) ($28,$78)
// ($28,$78) ($28,$28) ($3C,$3C) ($3C,$64)
// ($3C,$64) ($3C,$3C) ($46,$46) ($46,$5A)
// ($46,$5A) ($46,$46) ($4B,$4B) ($4B,$55)
        LDY fA509,X			// Move pen to lower
        LDA fA50E,X
        JSR s9359			// Set pen position from Y,A
        LDY fA50E,X
        LDA fA50E,X
        JSR s9315			// Draw line
        LDY fA513,X
        LDA fA513,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA513,X
        JSR s9315			// Draw line
        LDY fA509,X
        LDA fA50E,X
        JSR s9315			// Draw line
        LDA f7033,X			// Does the wall have a door ?
        CMP #$02
        BEQ b90AC			// If yes, branch to door drawing
        CMP #$03			// If not, is it an hidden door ?
        BNE b90D2			// If not, process right wall
        LDA a81				// Else check if light is on
        BEQ b90D2			// If not, don't draw hidden door and process right wall
// Draw door on left
// Coordinates of left door vertices for all 5 depth :
// ($00,$9F) ($00,$0A) ($06,$10) ($06,$9A) 
// ($14,$8C) ($14,$1C) ($24,$2C) ($24,$7C) 
// ($2C,$74) ($2C,$32) ($39,$3F) ($39,$67) 
// ($3F,$61) ($3F,$43) ($44,$48) ($44,$5C) 
// ($47,$59) ($47,$49) ($4A,$4C) ($4A,$56) 
b90AC   LDX a3D				// Load current view depth (0..4)
        LDY fA51D,X
        LDA fA522,X
        JSR s9359			// Set pen position from Y,A
        LDY fA527,X
        LDA fA522,X
        JSR s9315			// Draw line
        LDY fA52C,X
        LDA fA531,X
        JSR s9315			// Draw line
        LDY fA536,X
        LDA fA531,X
        JSR s9315			// Draw line
b90D2   JMP j918B			// draw wall on right

// Draw wall in front, at our left
// Coordinates of front wall at left vertices for all 5 depth :
// Warning : it does not draw the part that could be hidden by possible left wall at previous depth
// ($00,$0F) ($0F,$0F) ($0F,$91) ($00,$91)
// ($0F,$28) ($28,$28) ($28,$78) ($0F,$78)
// ($28,$3C) ($3C,$3C) ($3C,$64) ($28,$64)
// ($3C,$46) ($46,$46) ($46,$5A) ($3C,$5A)
// ($46,$4B) ($4B,$4B) ($4B,$55) ($46,$55)
b90D5   LDX a3D
        LDA f7042,X			// Is there a wall in front at our left at current depth ?
        BEQ b90D2			// draw wall on right
        LDY fA513,X
        LDA fA50E,X
        JSR s9359			// Set pen position from Y,A
        LDY fA513,X
        LDA fA513,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA513,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA50E,X
        JSR s9315			// Draw line
        LDA f7042,X			// Does the wall have a door ?
        CMP #$02
        BEQ b910F			// If yes, branch to door drawing
        CMP #$03			// If not, is it an hidden door ?
        BNE b912A			// If not, process hidden part of front wall at left
        LDA a81				// Else check if light is on
        BEQ b912A			// If not, don't draw hidden door and process hidden part of front wall at left
// Draw door in front, at our left
// Coordinates of left door vertices for all 5 depth :
// Warning : it does not draw the part that could be hidden by possible left wall at previous depth
// ($00,$1E) ($00,$1E) ($00,$91) 
// ($0F,$32) ($1E,$32) ($1E,$78) 
// ($28,$42) ($36,$42) ($36,$64) 
// ($3C,$4A) ($42,$4A) ($42,$5A) 
// ($46,$4D) ($49,$4D) ($49,$55)
b910F   LDY fA53B,X
        LDA fA50E,X
        JSR s9359			// Set pen position from Y,A
        LDY fA53B,X
        LDA fA540,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA540,X
        JSR s9315			// Draw line
		
// Draw the hidden part of front wall at left
b912A   LDX a3D				// Load previous view depth
        DEX 				// 
        CPX #$FF			// If depth was = 0, process wall on right
        BEQ j918B			
        LDA f7033,X			// Is there a wall on our left ?
        BNE j918B			// If so, process wall on right
        LDA f7042,X			// Is there a front wall on our left ?
        BNE j918B			// If so, process wall on right
// Coordinates of front wall at left vertices for all 5 depth :
// Note : this wall has no part hidden by other wall
// ($00,$0F) ($00,$00) ($00,$91) ($00,$91) <- may never be use...
// ($0F,$28) ($00,$28) ($00,$78) ($0F,$78)
// ($28,$3C) ($14,$3C) ($14,$64) ($28,$64)
// ($3C,$46) ($32,$46) ($32,$5A) ($3C,$5A)
// ($46,$4B) ($41,$4B) ($41,$55) ($46,$55)
        LDX a3D				// Here, $3D should never be zero...
        LDY fA513,X
        LDA fA50E,X
        JSR s9359			// Set pen position from Y,A
        LDY fA545,X
        LDA fA54A,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA54A,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA50E,X
        JSR s9315			// Draw line
        LDA f7042,X			// Does the wall have a door ?
        CMP #$02
        BEQ b9170			// If yes, branch to door drawing
        CMP #$03			// If not, is it an hidden door ?
        BNE j918B			// If not, process right wall
        LDA a81				// Else check if light is on
        BEQ j918B			// If not, don't draw hidden door and process right wall
// Coordinates of front door at left vertices for all 5 depth :
// Note : this door has no part hidden by other wall
// ($00,$1E) ($00,$00) ($00,$91) 
// ($0F,$32) ($00,$32) ($00,$78) 
// ($28,$42) ($1A,$42) ($1A,$64) 
// ($3C,$4A) ($36,$4A) ($36,$5A)
// ($46,$4D) ($43,$4D) ($43,$55)
b9170   LDY fA53B,X
        LDA fA50E,X
        JSR s9359			// Set pen position from Y,A
        LDY fA54F,X
        LDA fA554,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA554,X
        JSR s9315			// Draw line

// draw wall on our right		
j918B   LDX a3D				// Load current view depth (0..4)
        LDA f7038,X			// Is there a wall on right current depth ?
        BEQ b91F7			// if no, skip drawing
// Coordinates of left wall vertices for all 5 depth :
// ($9F,$9F) ($9F,$00) ($91,$0F) ($91,$91)
// ($91,$91) ($91,$0F) ($78,$28) ($78,$78)
// ($78,$78) ($78,$28) ($64,$3C) ($64,$64)
// ($64,$64) ($64,$3C) ($5A,$46) ($5A,$5A)
// ($5A,$5A) ($5A,$46) ($55,$4B) ($55,$55)
        LDY fA509,X
        LDA fA509,X
        JSR s9359			// Set pen position from Y,A
        LDY fA50E,X
        LDA fA509,X
        JSR s9315			// Draw line
        LDY fA513,X
        LDA fA518,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA518,X
        JSR s9315			// Draw line
        LDY fA509,X
        LDA fA509,X
        JSR s9315			// Draw line
        LDA f7038,X			// Does the wall have a door ?
        CMP #$02			// If yes, branch to door drawing
        BEQ b91CE
        CMP #$03			// If not, is it an hidden door ?
        BNE b91F4			// If not, process front wall
        LDA a81				// Else check if light is on
        BEQ b91F4			// If not, don't draw hidden door and process front wall
// draw door on right wall
// Coordinates of right door vertices for all 5 depth :
// ($9F,$9F) ($9F,$0A) ($9A,$10) ($9A,$9A) 
// ($8C,$8C) ($8C,$1C) ($7C,$2C) ($7C,$7C) 
// ($74,$74) ($74,$32) ($67,$3F) ($67,$67) 
// ($61,$61) ($61,$43) ($5C,$48) ($5C,$5C) 
// ($59,$59) ($59,$49) ($56,$4C) ($56,$56) 
b91CE   LDX a3D				// Load current view depth (0..4)
        LDY fA51D,X
        LDA fA51D,X
        JSR s9359			// Set pen position from Y,A
        LDY fA527,X
        LDA fA51D,X
        JSR s9315			// Draw line
        LDY fA52C,X
        LDA fA536,X
        JSR s9315			// Draw line
        LDY fA536,X
        LDA fA536,X
        JSR s9315			// Draw line
b91F4   JMP j92AD			// Process front wall

// Process front wall at our right
// Coordinates of front wall at left vertices for all 5 depth :
// Warning : it does not draw the part that could be hidden by possible left wall at previous depth
// ($9F,$0F) ($91,$0F) ($91,$91) ($9F,$91)
// ($91,$28) ($78,$28) ($78,$78) ($91,$78)
// ($78,$3C) ($64,$3C) ($64,$64) ($78,$64)
// ($64,$46) ($5A,$46) ($5A,$5A) ($64,$5A)
// ($5A,$4B) ($55,$4B) ($55,$55) ($5A,$55)
b91F7   LDX a3D
        LDA f7047,X			// Is there a wall in front at our right at current depth ?
        BEQ b91F4			// If not, process front wall
        LDY fA513,X
        LDA fA509,X
        JSR s9359			// Set pen position from Y,A
        LDY fA513,X
        LDA fA518,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA518,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA509,X
        JSR s9315			// Draw line
        LDA f7047,X			// Does the wall have a door ?
        CMP #$02
        BEQ b9231			// If yes, branch to door drawing
        CMP #$03			// If not, is it an hidden door ?
        BNE b924C			// If not, process hidden part of front wall at right
        LDA a81				// Else check if light is on
        BEQ b924C			// If not, don't draw hidden door and process hidden part of front wall at right
// Draw door in front, at our right
// Coordinates of right door vertices for all 5 depth :
// Warning : it does not draw the part that could be hidden by possible right wall at previous depth
// ($9F,$1E) ($9F,$1E) ($9F,$91) 
// ($91,$32) ($82,$32) ($82,$78) 
// ($78,$42) ($6A,$42) ($6A,$64) 
// ($64,$4A) ($5E,$4A) ($5E,$5A) 
// ($5A,$4D) ($57,$4D) ($57,$55) 
b9231   LDY fA53B,X
        LDA fA509,X
        JSR s9359			// Set pen position from Y,A
        LDY fA53B,X
        LDA fA559,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA559,X
        JSR s9315			// Draw line
		
// Draw the hidden part of front wall at right
b924C   LDX a3D				// Load previous view depth
        DEX 
        CPX #$FF			// If depth was = 0, process front wall
        BEQ j92AD
        LDA f7038,X			// Is there a wall on our right ?
        BNE j92AD			// If so, process front wall
        LDA f7047,X			// Is there a front wall on our right ?
        BNE j92AD			// If so, process front wall
// Coordinates of front wall at right vertices for all 5 depth :
// Note : this wall has no part hidden by other wall
// ($9F,$0F) ($00,$00) ($00,$91) ($9F,$91) 
// ($91,$28) ($9F,$28) ($9F,$78) ($91,$78)
// ($78,$3C) ($8C,$3C) ($8C,$64) ($78,$64)
// ($64,$46) ($6E,$46) ($6E,$5A) ($64,$5A)
// ($5A,$4B) ($5F,$4B) ($5F,$55) ($5A,$55)
        LDX a3D				// Here, $3D should never be zero...
        LDY fA513,X
        LDA fA509,X
        JSR s9359			// Set pen position from Y,A
        LDY fA545,X
        LDA fA55E,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA55E,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA509,X
        JSR s9315			// Draw line
        LDA f7047,X			// Does the wall have a door ?
        CMP #$02
        BEQ b9292			// If yes, branch to door drawing
        CMP #$03			// If not, is it an hidden door ?
        BNE j92AD			// If not, process front wall
        LDA a81				// Else check if light is on
        BEQ j92AD			// If not, don't draw hidden door and process front wall
// Coordinates of front door at right vertices for all 5 depth :
// Note : this door has no part hidden by other wall
// ($00,$1E) ($9F,$00) ($9F,$91) <- may never be use...
// ($0F,$32) ($86,$32) ($86,$78) 
// ($28,$42) ($6A,$42) ($6A,$64) 
// ($3C,$4A) ($5D,$4A) ($5D,$5A)
// ($46,$4D) ($82,$4D) ($82,$55) 
b9292   LDY fA53B,X
        LDA fA509,X
        JSR s9359			// Set pen position from Y,A
        LDY fA54F,X
        LDA fA563,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA563,X
        JSR s9315			// Draw line
		
// Process front wall
j92AD   LDX a3D				// Load current view depth (0..4)
        LDA a703D,X			// Is there a wall in front of us ?
        BEQ b9314			// If not, stop drawing current view depth
// Coordinates of left wall vertices for all 5 depth :
// ($0F,$0F) ($91,$0F) ($91,$91) ($0F,$91)
// ($28,$28) ($78,$28) ($78,$78) ($28,$78)
// ($3C,$3C) ($64,$3C) ($64,$64) ($3C,$64)
// ($46,$46) ($5A,$46) ($5A,$5A) ($46,$5A)
// ($4B,$4B) ($55,$4B) ($55,$55) ($4B,$55)
        LDY fA513,X
        LDA fA513,X
        JSR s9359			// Set pen position from Y,A
        LDY fA513,X
        LDA fA518,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA518,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA513,X
        JSR s9315			// Draw line
        LDY fA513,X
        LDA fA513,X
        JSR s9315			// Draw line
        LDA a703D,X			// Does the wall have a door ?
        CMP #$02
        BEQ b92F0			// If yes, branch to door drawing
        CMP #$03			// If not, is it an hidden door ?
        BNE b9314			// If not, stop current view depth drawing
        LDA a81				// Else check if light is on
        BEQ b9314			// If not, don't draw hidden door and stop current view depth drawing
// Draw door on front wall
// Coordinates of front door vertices for all 5 depth :
// ($1E,$91) ($1E,$1E) ($82,$1E) ($82,$91) 
// ($32,$78) ($32,$32) ($6E,$32) ($6E,$78) 
// ($42,$64) ($42,$42) ($5E,$42) ($5E,$64) 
// ($4A,$5A) ($4A,$4A) ($56,$4A) ($56,$5A) 
// ($4D,$55) ($4D,$4D) ($53,$4D) ($53,$55) 
b92F0   LDY fA518,X
        LDA fA53B,X
        JSR s9359			// Set pen position from Y,A
        LDY fA53B,X
        LDA fA53B,X
        JSR s9315			// Draw line
        LDY fA53B,X
        LDA fA568,X
        JSR s9315			// Draw line
        LDY fA518,X
        LDA fA568,X
        JSR s9315			// Draw line
b9314   RTS 

/////////////////////////////
// Draw line 
// input :
// Y = target pen Y
// A = target pen X
// ($4D) = current pen Y
// ($4F) = current pen X
/////////////////////////////
s9315   STY a4C				// save target Y in $4C
        STA a4E				// save target X in $4E
        LDA a4D				// initialize drawing Y in $4D with current Y
        STA a3E
        LDA a4F				// initialize drawing X in $4B with current X
        STA a4B
b9321   JSR s9360

// Update drawing Y
        LDA a3E				// Does drawing Y equal target Y ?
        CMP a4C
        BEQ b9336			// If true, check if pen has reached its target position
        BCS b9331			// Is drawing Y > target Y ?
        INC a3E				// if not, increment drawing Y
        JMP j933C			// update drawing X

b9331   DEC a3E				// if true, decrement drawing Y
        JMP j933C			// update drawing X

b9336   LDA a4B				// Does drawing X equal target X ?
        CMP a4E
        BEQ b934E			// If true, pen has reached its target position, update current pen position and exit
		
// Update drawing X
j933C   LDA a4B				// Does drawing X equal target X ?
        CMP a4E
        BEQ b9321			// if target X reached, loop on pixel draw
        BCS b9349			// Is drawing X > target X ?
        INC a4B				// If not, increment drawing X
        JMP b9321			// loop on pixel draw

b9349   DEC a4B				// else decrement drawing X
        JMP b9321			// loop on pixel draw

// let current pen position be the target one
b934E   LDA a4C
        STA a4D
        LDA a4E
        STA a4F
        LDX a3D				// restore X value
        RTS 

////////////////////////////
// Set pen position from A,Y
// Store A in $4F (pen X)
// Store Y in $4D (pen Y)
// Read X from $3D
////////////////////////////
s9359   STY a4D
        STA a4F
        LDX a3D
        RTS 

/////////////////////////////////////
// Draw pixel at current pen location
//
// input :
// $3E = pixel Y
// $4B = pixel X
/////////////////////////////////////
s9360   LDA a4B				// get X offset in its 8x8 block
        AND #$07
        EOR #$07			// flip to get complement (i.e A=(7-A) )
        TAX 
        LDA fA41C,X			// get bitmap value from table (Note : author could have reversed table and forgot about flipping...)
        STA a45				// Compute byte value to store in bitmap
		
// Compute address of bitmap byte to modify as if pen was in screen row 0, column Y
        LDA #$20			// Initialize MSB of bitmap start address
        STA aFC
        LDA a3E				// get Y offset in its 8x8 block
        AND #$07
        STA a51
        LDA a4B				// Compute address offset of first byte of block containing the pen location 
        AND #$F8			// it is relative to the address of first byte of block on the screen row containing pen
        CLC 
        ADC a51				// add Y offset in the block containing pen
        STA aFB
		
		
// Compute in ($FB).w the address of byte to modify in bitmap :
// Get the address offset (relative to $2000) of first byte of first block of screen row containing pen location
// Then, add to the address computed before in ($FB).w

// Compute screen row position (0..24) of 8x8 block containing pen
        LDA a3E				// get Y offset in its 8x8 block
        LSR 
        LSR 
        LSR 
        TAX 

// Look in table for bitmap address offset of first block on this screen row.
// And add it to current bitmap address to modify.
        LDA f5000,X			// load LSB of bitmap address offset of first 8x8 block at screen row X
        CLC 
        ADC aFB
        STA aFB
        BCC b9391			// Page overflow ? 
        INC aFC				// If true, increment MSB of bitmap address
b9391   LDA fA4E8,X			// load MSB of bitmap address offset (relative to $20) of first 8x8 block at screen row X
        CLC 
        ADC aFC
        STA aFC
		
// Logical OR of byte content, to prevent us from deleting previously written pixel
        LDY #$00
        LDA (pFB),Y
        ORA a45
        STA (pFB),Y
        RTS 

////////////////////////////////
// Clear 3D view and draw border
////////////////////////////////
s93A2   JSR s93C9			// Clear bitmap memory of 3D view area
        LDY #$00
        LDA #$00
        JSR s9359			// Clear pen position (0,0) and save X
        LDY #$00
        LDA #$9F
        JSR s9315			// Draw line (0,0)-(159,0)
        LDY #$9F
        LDA #$9F
        JSR s9315			// Draw line (159,0)-(159,159)
        LDY #$9F
        LDA #$00
        JSR s9315			// Draw line (159,159)-(0,159)
        LDY #$00
        LDA #$00
        JSR s9315			// Draw line (0,159)-(0,0)
        RTS 

//////////////////////////////////////
// Clear bitmap memory of 3D view area
//////////////////////////////////////
s93C9   LDX #$00			// line counter
b93CB   LDA fA4E8,X			// load MSB of bitmap address offset (relative to $20) of first 8x8 block at screen row X
        CLC 
        ADC #$20			// Add MSB of bitmap start address
        STA aFC
        LDA f5000,X			// load LSB of bitmap address of first 8x8 block at screen row X
        STA aFB
        LDY #$00
b93DA   LDA #$00
        STA (pFB),Y
        INY 
        CPY #$A0			// Clear 160 bytes (8*20, i.e 20 characters)
        BNE b93DA
        INX 				// Increment line counter
        CPX #$14			// 20 lines processed ?
        BNE b93CB			// if not, keep on erasing
        RTS 

/////////////////////////////////////////////////////////////////
// Clear bitmap and initialize bitmap colors stored in screen RAM
/////////////////////////////////////////////////////////////////
// Clear bitmap memory
s93E9   LDA #$20			// Clear $2000-$3FFF
        STA aFC
        LDA #$00
        STA aFB
        LDY #$00
b93F3   LDA #$00
        STA (pFB),Y
        INY 
        BNE b93F3
        INC aFC
        LDA aFC
        CMP #$40
        BNE b93F3
		
// Fill memory $0400-$0800 with $B1
// En mode bitmap, la Screen RAM sert à définir les couleurs.
// The Background Pixel Color is defined by Bits#0 - Bit#3 of the corresponding Byte in Screen RAM.  
// The Foreground Pixel Color is defined by Bits#4 - Bits#7 - again from the corresponding Byte in Screen RAM. 
// Remplissage de la mémoire $0400 -> $0800 avec $B1 (gris foncé sur fond blanc)
        LDA #$04
        STA aFC
        LDA #$00
        STA aFB
        LDY #$00
b940C   LDA #$B1
        STA (pFB),Y
        INY 
        BNE b940C
        INC aFC
        LDA aFC
        CMP #$08
        BNE b940C
		
// Modifie de la couleur de fond de la zone bitmap correspondant
// a la vue 3D du labyrinthe
        LDA #$04
        STA aFC
        LDA #$00
        STA aFB
        STA a3D				// reset line index
        LDY #$00
b9427   LDX #$00
b9429   LDA #$BF			// Gris foncé sur fond gris léger
        STA (pFB),Y
        INY 
        BNE b9432
        INC aFC
b9432   INX 
        CPX #$14			// 20 blocs de 8x8 traités ? (largeur fenetre 3D)
        BNE b9429			// Sinon on traite le bloc suivant
        TYA 				// Skip next 20 blocks
        CLC 
        ADC #$14
        TAY 
        BCC b9440			// page overflow (more than 256 blocs processed) ?
        INC aFC				// increment MSB of screen ram pointer
b9440   INC a3D
        LDA a3D				// 20 lines processed ?
        CMP #$14
        BNE b9427			// If not, change background color of next 20 blocks of next line
		
        JSR s9C29			// RED logo on WHITE background

// Modify background color of messages area on the right (18x15 blocks)
// Use a white foreground on grey background
        LDA #$00
        STA aFB
        STA a3D				// reset line counter
        LDA #$04
        STA aFC
        LDY #$DD			// Start a column 21, row 5
b9457   LDX #$00			// Reset block counter 
b9459   LDA #$1C			// WHITE foreground on GREY background
        STA (pFB),Y
        INY 
        BNE b9462
        INC aFC
b9462   INX 
        CPX #$12			// 18 blocks processed ?
        BNE b9459			// if not, process next one
        TYA 				// else skip 22 blocks
        CLC 
        ADC #$16
        TAY 
        BCC b9470
        INC aFC
b9470   INC a3D				// increment line counter
        LDA a3D
        CMP #$0F			// 15 lines processed ?
        BNE b9457			// if not, process next block
		
// Fill $8000-$80FF with random values... WHY ?? Kind of copy protection system ?
// When using a cartridge, this memory is mapped to game ROM. So, it is not writable.
// When using a D64 version of game, it writes to RAM and erase first bytes of game code.
// Code at $8000-$80FF deals with initialization and doest not need to be called again
// at game runtime. So, it is not a big issue...
        LDA #$40
        STA a3C
        LDA #$00
        STA a3B
        LDA #$C0
        SEC 
        SBC a3C
        STA a3C
        LDY #$00
b9489   LDA $D41B    		// load random byte
        STA (p3B),Y
        INY 
        BNE b9489
        RTS 

////////////////////////////////////////////////////
// Clear whole menu screen (reset bitmap and colors)
////////////////////////////////////////////////////
// RAZ de la mémoire bitmap de $2000 -> $3FFF
s9492   LDA #$20
        STA aFC
        LDA #$00
        STA aFB
        LDY #$00
b949C   LDA #$00
        STA (pFB),Y
        INY 
        BNE b949C
        INC aFC
        LDA aFC
        CMP #$40
        BNE b949C
// En mode bitmap, la Screen RAM sert à définir les couleurs.
// The Background Pixel Color is defined by Bits#0 - Bit#3 of the corresponding Byte in Screen RAM.  
// The Foreground Pixel Color is defined by Bits#4 - Bits#7 - again from the corresponding Byte in Screen RAM. 
// Remplissage de la mémoire $0400 -> $0800 avec $1B (blanc sur fond gris foncé)
        LDA #$04
        STA aFC
        LDA #$00
        STA aFB
        LDY #$00
b94B5   LDA #$1B
        STA (pFB),Y
        INY 
        BNE b94B5
        INC aFC
        LDA aFC
        CMP #$08
        BNE b94B5
        RTS 

///////////////////////////
// Random monster encounter
// input : monster ID in ACC
///////////////////////////
j94C5   LDA $D41B   	// load random monster ID in range ($0..$F)
        AND #$0F		
j94CA   LDX a84			// load level (current floor)
j94CC   CPX #$00		// add 6*level to monster ID -> final monster ID in range ($0..$27=Balrog)
        BEQ b94D7
        DEX 
        CLC 
        ADC #$06
        JMP j94CC

// If monster ID is 39 ($27), ensure that party position is (3,19) (BALROG location)
// If party is anywhere else, load monster ID 25 ($19) instead...
b94D7   STA a88			// save monster ID at $88
        CMP #$27		// monster ID 39 ?
        BNE b94F0		// In such a case, ensure that party position is (3,19) (BALROG location)
        LDA a48			// Load YPos
        CMP #$13
        BNE b94EC
        LDA a62			// Load XPos
        CMP #$03
        BNE b94EC
        JMP b94F0

b94EC   LDA #$19
        STA a88
			
b94F0   LDA a88			// load monster ID (range $0..$27)
        ASL 			// multiply by 4 (range $0..$9C) to get offset
        ASL 
        TAX 
// Monsters data are store at $BE60
// first byte is mult-color 0
// second byte is mult-color 0
// third byte is the MSB of monster TOP sprite (LSB is $00)
// fourth byte is the MSB of monster BOTTOM sprite (LSB is $80)
        LDA fBE60,X
        STA $D025    	// Sprite Multi-Color Register 0
        LDA fBE61,X
        STA $D026    	// Sprite Multi-Color Register 1

// Compute start address of monster bottom SPRITES.
// MSB is stored in the third byte of a monster entry, starting at $BE60.
// LSB is zero. Please note that the copy routine add $80 to this address.
        LDA fBE63,X		// load MSB of ($FB).w
        STA aFC
        LDA #$00		// set LSB of ($FB).w to 0
        STA aFB

// Compute start address of monster top SPRITES.
// MSB is stored in the fourth byte of a monster entry, starting at $BE60.
// If MSB < $B0, add $B0 to it and set LSB to $80
// else set LSB to zero
        STA a3B			// reset LSB of ($3B).w
        LDA fBE62,X		// load MSB of ($3B).w
        CMP #$B0		// if MSB is < $B0
        BCS b951A
        LDY #$80		// set LSB of ($FB).w to $80 
        STY a3B
        CLC 
        ADC #$B0		// and add $B0 to MSB of ($FB).w
b951A   STA a3C	
		
// Copy the two top sprites of monster into VIC bank at $0F00 (monster HEAD)
// Copy 128 bytes from ($3B).w to $0F00..$0F7F
        LDY #$00
b951E   LDA (p3B),Y
        STA f0F00,Y
        INY 
        CPY #$80
        BNE b951E
		
// Copy the two bottom sprites of monster into VIC bank at $0F80 (monster FOOT)
// Copy 128 bytes from (($FB).w + $80) to $0F80..$0FFF
b9528   LDA (pFB),Y		// here Y starts at $80
        STA f0F00,Y
        INY 
        BNE b9528
		
        JSR s93A2		// Clear 3D view and draw border
        LDA #$0F		// Display sprites 0..3
        STA $D015    	// Sprite display Enable
        JSR s9C6D		// Invert temporarily colors of MAZE MASTER logo
		
// Play a sound while bliking the MAZE MASTER logo
        LDA #$09
        STA $D405    	// Voice 1: Attack / Decay Cycle Control
        LDA #$85
        STA $D418    	// Select Filter Mode and Volume
        LDA #$05
        STA $D401    	// Voice 1: Frequency Control - High-Byte
        LDA #$D0
        STA $D406    	// Voice 1: Sustain / Release Cycle Control
        LDA #$32
        STA $D400    	// Voice 1: Frequency Control - Low-Byte
        LDA #$21
        STA $D404    	// Voice 1: Control Register
        JSR s9C6D		// Invert temporarily colors of MAZE MASTER logo
        JSR s9C6D		// Invert temporarily colors of MAZE MASTER logo
        LDA #$00
        STA $D400    	// Voice 1: Frequency Control - Low-Byte
        STA $D401    	// Voice 1: Frequency Control - High-Byte
        STA a7A			// reset name display counter
        LDA #$20
        STA $D404    	// Voice 1: Control Register
        JSR s9C6D		// Invert temporarily colors of MAZE MASTER logo
		
// Display monster name in message window
        JSR sA347		// Reset message window and cursor
        LDA #$18		// column 24
        STA a49
        LDA a88			// load monster ID
        CMP #$1B		// is it >= 27 ?
        BCC b95A9
        SEC 
        SBC #$1B		// if so, load X with ID - 27 (range $0..$C)
        TAX 
        LDA fA463,X		// Get monster name offset from $A463 + X
        STA a47			// store one of these values ($0,$8,$13,$1D,$2A,$38,$43,$4B,$59,$64,$78,$85,$92) at $47
        TAY 			
j9588   LDA fA90B,Y		// load next char of character monster at $A90B 
        CMP #$FF		// names are delimited by byte $FF
        BEQ b9596
        JSR s9E94		// Output char in AC
        INY 
        JMP j9588

// And also at bottom of 3D view
b9596   LDA a7A
        BNE b95D1		// name already displayed twice ? If so, compute and display number of fighting monsters
        LDA #$12		// if not, place cursor at (5,18)
        STA a4A
        LDA #$05		
        STA a49
        INC a7A			// increment name display counter
        LDY a47			// reload monster name offset from $A463 + X
        JMP j9588		// display monster name

b95A9   TAX 			// if monster ID is < 27
        LDA fA448,X		// Get monster name offset from $A448 + X
        STA a47			// store one of these values ($0,$8,$10,$18,$22,$2a,$35,$3c,$45,$4d,$57
        TAY 			// $5f,$6a,$71,$76,$7e,$84,$8b,$96,$a3,$ae,$bb,$c8,$d4,$db,$e4,$f2) at $47
j95B0   LDA fA80D,Y		// load next char of character monster at $A80D 
        CMP #$FF		// names are delimited by byte $FF
        BEQ b95BE
        JSR s9E94		// Output char in AC
        INY 
        JMP j95B0

b95BE   LDA a7A
        BNE b95D1		// name already displayed twice ? If so, compute and display number of fighting monsters
        LDA #$12		// if not, place cursor at (5,18)
        STA a4A
        LDA #$05
        STA a49
        INC a7A			// increment name display counter
        LDY a47			// reload monster name offset from $A463 + X
        JMP j95B0		// display monster name

// Compute and display number of fighting monsters
b95D1   LDA #$06		// row number 6
        STA a4A
        LDA $D41B   	// Get a random value between 1 & 4
        AND #$03
        CLC 
        ADC #$01
        STA a45
        LDA a84			// load level (current floor)
        AND #$03		// mask to get value in range 0..3
        CLC 
        ADC a45			// add to random value
        STA a74			// and store it at $74
        LDA a80			// are they wandering masters ?
        BEQ b95F0
        INC a74			// if so, add 2 more units to the fighting horde !
        INC a74
b95F0   LDA a88			// load monster ID
        CMP #$27		// is it a Balrog ?
        BNE b95FA
        LDA #$01		// if true, let fight only 1 unit
        STA a74
b95FA   LDA #$16		// output number of monsters at (22,6)
        STA a49
        LDA a74			
        JSR s9E94		// Output char in AC
        JSR sA36B		// Two line returns in message window and reset X
		
// Ouput screen codes 4A,0F,28,12,10,11,1D,24,18,1B,24,4A,1B,28,1E,17 (22,9)
// that matches chars "(F)IGHT OR (R)UN"
b9606   LDA fBC00,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$10
        BNE b9606
		
b9611   JSR s9E8E		// Lecture bloquante touche clavier
        CMP #$46		// Key 'F' pressed ?
        BEQ b9647		// Start fight
        CMP #$52		// Key 'R' pressed ?
        BNE b9611		// If not, loop on keyboard read
	
// Try to run away from monsters
        JSR sA36B		// Two line returns in message window and reset X
        JSR s9AA7		// Compute fight engage
        BNE b9637		// Does monster engage ?
	
// Party engages and so, can run away	
// Ouput screen codes 22,18,1E,24,10,18,1D,24,0A,20,0A,22,26,26,26 in message window
// that matches chars "YOU GO AWAY..."
j9624   LDX #$00
b9626   LDA fBC20,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0F
        BNE b9626
		
        JSR s9AF1		// Long waiting loop...
        JMP j9BDD		// terminate fight

// Monster engages and so, catch party
// Ouput screen codes 1D,11,0E,22,24,0C,0A,1E,10,11,1D,24,22,18,1E in message window
// that matches chars "THEY CAUGHT YOU"
b9637   LDX #$00
b9639   LDA fBC2F,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0F
        BNE b9639
        JSR s9AF1		// Long waiting loop...
	
// Start fight	
b9647   LDY a88			// load monster ID
        LDX #$00		// reset fighting monster index
        STX a704D		// AR reduction due to protection spell
        STX a7051		// reset number of dead monsters
        STX a36			// party hit score bonus 
        STX a35			// counter for 'E' key check (infight escape)
b9655   LDA fA498,Y		// load monster HP
        STA f6000,X		// store it as initial HP of each encountered monster
        INX 			// increment fighting monster index
        CPX a74			// all monsters processed ?
        BNE b9655
        JSR s9AA7		// Compute fight engage.
        BEQ b9668		// party engages
        JMP j992F		// Monsters attack

// party engage
b9668   LDA #$08		// let ($3B).w point to first character date
        STA a3C
        LDA #$00
        STA a3B
j9670   JSR sA347		// Reset message window and cursor
        LDY #$00		// Is there a character in current slot ?
        LDA (p3B),Y
        CMP #$24
        BNE b967E		// If so, ask for character action
        JMP j970A		// Else, let monsters attack (?)

b967E   LDY #$14		// load character class
        LDA (p3B),Y
        CMP #$01		// is it a warrior ?
        BEQ b968B
        LDA #$00		// if not, branch to wizard action
        JMP j9694

// Compute number of strikes for warrior
b968B   LDY #$1F		// load MSB of tmp experience of character
        LDA (p3B),Y		
        LSR 			// divide by 32
        LSR 
        LSR 
        LSR 
        LSR 
j9694   LDY #$24		// store this value (=tmp experience / 8192)
        STA (p3B),Y		// at offset $24 of character data
        LDY #$00		
		
// display character name at (22,6)
b969A   LDA (p3B),Y		// load a name char
        JSR s9E94		// Output char in AC
        INY 
        CPY #$10
        BNE b969A
        JSR sA36D		// One line return in message window and reset X
		
// Ouput screen codes 4A,20,28,0E,0A,19,24,18,1B,24,4A,1C,28,19,0E,15 (22,7)
// that matches chars "(W)EAP OR (S)PEL"
b96A7   LDA fBC10,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$10
        BNE b96A7
		
b96B2   JSR s9E8E		// Lecture bloquante touche clavier
        CMP #$53		// 'S' key pressed ?
        BEQ b96C6		// ask for spell number
        CMP #$57		// 'W' key pressed ?
        BNE b96B2		// if not, loop on get keyboard input
        LDA #$00		
        LDY #$22
        STA (p3B),Y		// else, if true, store action value 0 at offset $22
        JMP j96FF		// ask for next character action

b96C6   JSR sA36B		// Two line returns in message window and reset X
// Ouput screen codes 1C,19,0E,15,15,24,17,1E,16,0B,0E,1B,2A,24 (22,7)
// that matches chars "SPELL NUMBER: "
b96C9   LDA fBC88,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0E
        BNE b96C9
		
        JSR s9FFC		// lit 3 caracteres  depuis le clavier
        JSR s9F9D		// Convert a decimal value from input buffer into ($75).w
        LDA a75			// load entered value
        CMP #$12		// is spell number >= 18 
        BCC b96E2
b96E0   LDA #$00		// if so, store action value 0 at offset $22 (weapon)
b96E2   LDY #$22		// else store spell number at offset $22
        STA (p3B),Y
        TAX 
        CMP #$00		// if character use weapon (or invalid spell),
        BEQ j96FF		// then ask for next character action
        LDA fA3C0,X		// table indexed with spell number, storing zero value for combat spells
        BNE b96E0		// if spell is not a combat spell, let character uses its weapon
        LDY #$21		// load character spell points
        LDA (p3B),Y
        CMP fA3D3,X		// has character enough spell points for this spell
        BCC b96E0		// if not, let character uses its weapon
        SEC 
        SBC fA3D3,X		// remove used spell points
        STA (p3B),Y		// and update character spell points
		
j96FF   INC a3C			// let ($3B).w point to next character data
        LDA a3C			
        CMP #$0B		// all characters processed ?
        BEQ j970A		// if not, ask for next character action
        JMP j9670		// else process characters actions

// process characters actions
j970A   LDA #$08		// let ($3B).w point to first character data
        STA a3C
j970E   JSR sA347		// Reset message window and cursor
        JSR s9C7A		// check 'E' key for fight escape (if success, subroutine shortcuts fight)
        LDY #$00		// is there a character in current slot ?
        LDA (p3B),Y
        CMP #$24
        BNE b971F
        JMP j992F		// if not, all character have attacked. Let monsters attack...

// Display character name in message window
b971F   LDA (p3B),Y
        JSR s9E94		// Output char in AC
        INY 
        CPY #$10
        BNE b971F
        JSR sA36D		// One line return in message window and reset X
        LDY #$22		// Get character spell number casted (0 for weapon)
        LDA (p3B),Y
        BNE b9735		// if not null, character cast a spell
        JMP j97FF		// else he uses its weapon

// Character has casted a magic spell
// Ouput screen codes 0C,0A,1C,1D,1C,24,0A,24,1C,19,0E,15,15,26,26,26 (22,7)
// that matches chars "CAST A SPELL..."
b9735   LDA fBC3E,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$10
        BNE b9735
		
        LDA (p3B),Y
        CMP #$01		// Spell 1 ? (FIREBALL)
        BEQ b9755		// branch to common attack spell
        CMP #$05		// Spell 5 ? (FLAME BLAST)
        BEQ b9755		// branch to common attack spell
        CMP #$09		// Spell 9 ? (MIND FIST)
        BEQ b9755		// branch to common attack spell
        CMP #$11		// Spell 17 ? (FLAME FURY)
        BEQ b9755		// branch to common attack spell
        JMP j97E6		// Process other combat spells (protection and accuracy)

//////////////////////////////////////////////////////////////////////
// Cast spell 1 : Fireball
// This spell sends out a ball of fllames, which does 1-32 points
// of damage to 1 monster..
//
// Cast spell 5 : Flame blast
// This spell will send out a firey arc, burning all surviving 
// monsters for 1-16 points of damage.
//
// Cast spell 9 : Mind fist
// This spell deals all surviving monsters a crushing blow. and 
// does 1-32 points of damage to each.
//
// Cast spell 17 : Flame fury
// This spell causes an incendiary explosion to occur among your foes,
// doing 1-64 points of damage to each..
//////////////////////////////////////////////////////////////////////
b9755   STA a87			// save spell number at $87
        LDX #$00
        STX a47
j975B   LDA #$00
        STA a7A			// killed monster flag
// compute dommage of spell
        LDX a87			// load spell number in X
        LDA $D41B    	// load random value
        AND fA3F5,X		// use mask to limit spell dammage (0..31, 0..15, ..)
        CLC 
        ADC #$01		// add 1 to range (1..32, 1..16, ...)
        STA a39			// store spell dammage at $39
        LDA a84			// load level (current floor)
        ASL 			// multiply by 2
        CLC 
        ADC a39			// and multiply by spell dommage
        STA a39
        LDX a47			// load monster counter
        LDA f6000,X		// get HP of current monster
        BEQ b97D5		// if monster is already dead, process next one
        SEC 
        SBC a39			// if not, deals dommage to monster
        BCS b9782		// do HP go negative ?
        LDA #$00		// if so, set HP to 0
b9782   CMP #$00
        BNE b9788
        INC a7A			// set dead monster flag
b9788   STA f6000,X		// store HP of current monster
        JSR sA36D		// One line return in message window and reset X
        LDA a7A			// If monster is not dead, display 'HIT' message
        BEQ b97AD		// display 'HIT' message

// Current monster killed
// output byte 14,12,15,15,0E,0D,24,18,17,0E at (22,8)
// that matches chars "KILLED ONE"
b9792   LDA fBC5B,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0A
        BNE b9792
        INC a7051		// increment number of dead monster
        LDA a7051		// are all monsters dead ?
        CMP a74
        BCC b97AA		// if not, process next monster
        JMP j9B01		// display and assign loots (gold & experience)

b97AA   JMP j97CC		// process next monster if possible

// output byte 11,12,1D,1C,24,0F,18,1B,24 at (22,8)
// that matches chars "HITS FOR "
// output byte 24,19,1D,1C on same row
// that matches chars " PTS"
b97AD   LDA fBC4E,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0D
        BEQ j97CC		// 'Hit' message line written, process next monster if possible
        CPX #$09
        BNE b97AD
// display decimal value in $75.w matching spell damage
        LDA #$00
        STA a76
        LDA a39			// load spell dommage
        STA a75
        JSR sA1ED		// Display word value stored in ($75).w
        LDX #$09
        JMP b97AD

// If spell is multi target, process next monster
// else deal with next character attack
j97CC   LDA a87			// Is it spell number 1 ? (mono target)
        CMP #$01
        BNE b97D5		// if not, spell also hurts other monsters
        JMP j990B		// Current character attack done

b97D5   INC a47			// increment monster counter
        LDA a47
        CMP a74			// all monster processed ?
        BNE b97E0		// if not, spell hit also next monster
        JMP j990B		// Current character attack done

// Spell hit also next monster
b97E0   JSR s9C62		// waiting loop
        JMP j975B		// loop on computing spell damage for next monster

// A protection spell has been in cast during fight
j97E6   TAX 			// load spell number in X
        CPX #$0D		// Is it spell number 13 (ACCURACY) ?
        BEQ b97F8		// if so, set increase party HIT score
        LDA fA3F5,X		// if not, load AR reduction of this spell
        CLC 
        ADC a704D		// cumulate AR reduction
        STA a704D
        JMP j990B		// Current character attack done

b97F8   LDA #$04		// add 4 to party hit score
        STA a36
        JMP j990B		// Current character attack done

// Character attacks with weapon
// Compute HIT score based on random value, dexterity, magical bonus, magic item
// and warrior experience bonus
j97FF   LDA $D41B    	// load an random value in range 2..17
        AND #$0F
        CLC 
        ADC #$02
        STA a73			// save value at $73
        LDY #$12		// load dexterity of character
        LDA (p3B),Y
        JSR sA376		// Compute X=A-$0F, if X>$0F (bonus for high stat)
        TXA 			// load stat bonus in ACC
        CLC 
        ADC a73			// add bonus to random value
        CLC 
        ADC a36			// add optional party hit score
        STA a73
        LDY #$1C		// look for a magic item in inventory
        LDA (p3B),Y
        CMP #$02		// Is it a 'Ring of accuracy' ?
        BNE b9828
        LDA #$04		// Add a bonus of 4 to hit score
        CLC 
        ADC a73
        STA a73
b9828   LDY #$14		// Load class type
        LDA (p3B),Y
        CMP #$01		// is it warrior ?
        BNE b983C		
        LDY #$1F		// if true, get MSB of tmp experience
        LDA (p3B),Y		
        LSR 			// and divide by 8
        LSR 
        LSR 
        CLC 
        ADC a73			// add (tmp experience / 2048) to hit score
        STA a73
b983C   LDX a88			// load monster ID in X
        LDA fA4C0,X		// load monster AR (ranging $0..$14) <-> (-10..+10)
        TAX 
        LDA f5300,X		// load dodge score matching this AR (score = $1C for an AR of -10 and score = $08 for an AR of +10)
        CMP a73			// if HIT score > monster dodge score, attack succeeded
        BCC b9859		
        LDX #$03		// else character missed

// output byte 16,12,1C,1C,0E,0D,1D at (22,8)
// that matches chars "MISSED"
b984B   LDA fBC65,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$09
        BNE b984B
        JMP j990B		// Current character attack done

// attack succeeded
b9859   LDY #$19		// get character weapon ID
        LDA (p3B),Y
        TAX 
// dammage for each weapon :
// None =  1..4
// Sword = 1..8
// Magic sword = 1..16
// Rune-mace = 1..32
// Wrathblade = 1..64
        LDA $D41B    	// load random value
        AND fA407,X		// get weapon damage mask
        CLC 
        ADC #$01
        STA a39			// store damage at $39
        LDY #$10		// load character strength
        LDA (p3B),Y
        JSR sA376		// Compute X=A-$0F, if X>$0F (bonus for high stat)
        TXA 
        CLC 
        ADC a39			// add strength bonus to damage
        STA a39
        LDY #$14		// load character class
        LDA (p3B),Y
        CMP #$01		// is it a warrior ?
        BNE b988A
        LDY #$1F		// if true, get MSB of tmp experience
        LDA (p3B),Y
        LSR 			// and divide by 8
        LSR 
        LSR 
        CLC 
        ADC a39			// add (tmp experience / 2048) to damage
        STA a39
b988A   LDA a39
        CMP #$05		// is damage < 5 ?
        BCS b9895
        LDX #$00		// if so, load text offset with 0
        JMP j98A0

b9895   CMP #$14		// else is damage < 20 ?
        BCS b989E
        LDX #$10		// if so, load text offset with 16
        JMP j98A0

b989E   LDX #$20		// else load text offset with 32

// Output attack text according to amount of damage :
// damage < 5 : bytes 10,15,0A,17,0C,0E,1C,24,11,12,1C,24,0F,18,0E
// that matche char "GLANCES HIS FOE"
// damage < 20 : bytes 1C,15,0A,1C,11,0E,1C,24,11,12,1C,24,0F,18,0E
// that matche char "SLASHES HIS FOE"
// damage >= 20 : bytes 1C,1D,1B,12,14,0E,1C,24,16,12,10,11,1D,12,15,22
// that matche char "STRIKES MIGHTILY"
j98A0   LDA fB780,X
        CMP #$FF
        BEQ b98AE
        JSR s9E94		// Output char in AC
        INX 
        JMP j98A0

b98AE   JSR sA36D		// One line return in message window and reset X
        LDX #$00		// Clear MSB of word to display
        STX a76
		
// output byte 11,12,1D,1C,24,0F,18,1B,24 in message window
// that matches chars "HITS FOR "
// output byte 24,19,1D,1C at (22,8) in message window
// that matches chars " PTS"
b98B5   LDA fBC4E,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0D
        BEQ b98D0
        CPX #$09
        BNE b98B5
// if 9 chars display, insert decimal value of damage done
        LDA a39			// Load LSB of word to display with damage value 
        STA a75
        JSR sA1ED		// Display word value stored in ($75).w
        LDX #$09
        JMP b98B5

// Remove HP of the first monster still alive
b98D0   LDX #$00
b98D2   LDA f6000,X		// get HP of current monster
        BNE b98DF		// is this monster is still alive ?
        INX 			// if not, check next monster HP
        CPX a74			// if all monsters are dead
        BNE b98D2
        JMP j9B01		// display and assign loots (gold & experience)

b98DF   SEC 
        SBC a39			// substract damage from current monster HP
        STA f6000,X		// store HP of current monster
        BCS b98E9		// if monster HP goes negative
        LDA #$00		// load HP with 0
b98E9   CMP #$00
        BNE j990B		// Monster is not dead, current character attack done
        STA f6000,X		// Monster is dead, set HP of current monster to 0
        INC a7051		// increment number of dead monster
        JSR sA36D		// One line return in message window and reset X
// output byte 14,12,15,15,0E,0D,24,18,17,0E in message window
// that matches chars "KILLED ONE"
b98F6   LDA fBC5B,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0A
        BNE b98F6
// if there monsters still alive, keep on fighting
        LDA a7051		// load number of dead monster
        CMP a74			// are all monsters dead ?
        BNE j990B		// if not, current character attack done
        JMP j9B01		// display and assign loots (gold & experience)

// Current character attack done
j990B   JSR s9AF1		// Long waiting loop...
        LDY #$14		// is current character a warrior ?
        LDA (p3B),Y
        CMP #$01		// if he is wizard then his turn is completed
        BNE b9924		// process to next character attack
        LDY #$24		// else load character strikes counter (tmp experience / 8192)
        LDA (p3B),Y
        BEQ b9924		// if cap 0, process to next character attack
        SEC 
        SBC #$01		// else decrement striked counter
        STA (p3B),Y
        JMP j970E		// process next character attack

b9924   INC a3C			// let ($3B).w points to the next character
        LDA a3C
        CMP #$0B		// all character attacks processed ?
        BEQ j992F		// Monsters attack
        JMP j970E		// loop on character attack

// Monsters attack
j992F   JSR sA347		// Reset message window and cursor
// Ouput screen codes 16,18,17,1C,1D,0E,1B,1C,24,0A,1D,1D,0A,0C,14 at (22,6)
// that matches chars "MONSTERS ATTACK"
        LDX #$00
        STX a7A			// initialize current monster index
b9936   LDA fA9A4,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0F
        BNE b9936
		
        JSR s9AF1		// Long waiting loop...
        JSR sA347		// Reset message window and cursor

// Look for next monster still alive
b9947   LDX a7A			// load monster index
        LDA f6000,X		// load HP of current monster
        CMP #$00		// is monster dead ?
        BNE b995A
        INX 			// if so, skip this monster 
        INC a7A			// increment monster index
        CPX a74			// are all monsters dead ?
        BNE b9947		// if not, let next monster attack
        JMP j9B01		// display and assign loots (gold & experience)

// Select the targeted character and let $3B.w points to his data
b995A   LDA $D41B    	// Load a random value in range 0..3
        AND #$03
        CMP #$03		// if value == 3, set it to 0
        BNE b9965
        LDA #$00
b9965   CLC 			// let $3B.w points to a random character data structure
        ADC #$08
        STA a3C
        LDA #$00
        STA a3B
        LDY #$00		// is this character still alive ?
        LDA (p3B),Y
        CMP #$24
        BNE b997A
        LDA #$08		// if not, use first character
        STA a3C
		
b997A   LDY #$20		// load armor rating of this character
        LDA (p3B),Y
        SEC 
        SBC a704D		// apply AR reduction due to protection spell
        BCS b9986
        LDA #$00		// ensure AR does not go below 0 (-10 displayed)
b9986   TAX 
        LDA f5300,X		// load dodge score matching this AR (score = $1C for an AR of -10 and score = $08 for an AR of +10)
        STA a73			// save dodge score at $73
        LDA $D41B    	// load a random value in range 5..20
        AND #$0F
        CLC 
        ADC #$05
        LDX a88			// load monster ID in X
        CLC 
        ADC fA470,X		// add monster attack bonus to get attack score
        CMP a73			// if monster attack score >= character dodge score
        BCS b99A3
        LDA #$00		// set monster damage to 0
        JMP j99CA		// Display monster attack result

// Compute monster damage. It is the sum of a random number (1..8)
// and N*rand(1..8) where N is the monster attack bonus
b99A3   LDA $D41B    	// load a random value in range 1..8 (base attack)
        AND #$07
        CLC 
        ADC #$01
        STA a73			// store at $73
        LDX a88			// load monster ID
        LDA fA470,X		// load monster attack bonus
        TAX 
        LDA a73			// reload previous random value
j99B5   CPX #$00		// while monster attack bonus > 0
        BEQ j99CA		// attack damage computed. Now display monster attack result
        STA a39
        LDA $D41B    	// load random value in range 1..8 (bonus attack)
        AND #$07
        CLC 
        ADC #$01
        CLC 
        ADC a39			// add attack bonus to attack value
        DEX 			// decrement attack bonus
        JMP j99B5		// loop until attack is 0

// Display monster attack result
// display character name in message windows
j99CA   STA a39			// store monster damage at $39
        LDY #$00
b99CE   LDA (p3B),Y
        JSR s9E94		// Output char in AC
        INY 
        CPY #$10
        BNE b99CE
		
        JSR sA36D		// One line return in message window and reset X
        LDA a39
// If monster damage is zero, output screen codes 0D,18,0D,10,0E,1C,24,1D,11,0E,24,0B,15,18,20
// that matches chars "DODGES THE BLOW"
        BNE b99ED
b99DF   LDA fB7B1,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0F
        BNE b99DF
        JMP j9A80		// refresh view footer and process to next monster attack

// Damages are not null.
// Output various string according to damage value :
// damage < 7 : bytes 12,1C,24,1C,0C,1B,0A,19,0E,0D
// that matche char "IS SCRAPED"
// damage < 25 : bytes 12,1C,24,1C,15,0A,1C,11,0E,0D
// that matche char "IS SLASHED"
// damage >= 25 : bytes 12,1C,24,0B,0A,1D,1D,0E,1B,0E,0D
// that matche char "IS BATTERED"
b99ED   CMP #$07
        BCS b99F6
        LDX #$0F
        JMP j9A01

b99F6   CMP #$19
        BCS b99FF
        LDX #$1A
        JMP j9A01

b99FF   LDX #$25
j9A01   LDA fB7B1,X
        CMP #$FF
        BEQ b9A0F
        JSR s9E94		// Output char in AC
        INX 
        JMP j9A01

b9A0F   JSR sA36D		// One line return in message window and reset X
        LDX #$00		// set MSB of value to display to 0
        STX a76
// Ouput screen codes 1D,0A,14,0E,1C,24 in message window
// that matches chars "TAKES "
// Ouput screen codes 24,0D,0A,16,0A,10,0E,0A in message window
// that matches chars " DAMAGE"
b9A16   LDA fBC6E,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0D
        BEQ b9A31
        CPX #$06		// 6 first chars displayed ?
        BNE b9A16
        LDA a39			// if so, load damage value in LSB of word to display
        STA a75
        JSR sA1ED		// Display word value stored in ($75).w
        LDX #$06
        JMP b9A16

// Update current character CND and kill him if his condition is 0
b9A31   LDY #$1D		// load character CND (current HP)
        LDA (p3B),Y
        SEC 
        SBC a39			// substract damage taken
        STA (p3B),Y
        BCC b9A40		// is current CND > 0 ?
        CMP #$00		
        BNE j9A80		// if true, refresh view footer and process to next monster attack
b9A40   LDA #$00		// else set current CND to 0
        STA (p3B),Y
        JSR sA36D		// One line return in message window and reset X
// Ouput screen codes 0A,17,0D,24,12,1C,24,14,12,15,15,0E,0D in message window
// that matches chars "AND IS KILLED"	
b9A47   LDA fBC7B,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0D
        BNE b9A47

        LDA a3C			// is current character the first one ?
        CMP #$08
        BNE b9A5E
        JSR sA0BE		// if true, delete character 1 data
        JMP j9A6B		// refresh footer and terminate this monster attack
b9A5E   CMP #$09		// else is current character the second one ?
        BNE b9A68
        JSR sA0C9		// delete character 2 data
        JMP j9A6B		// refresh footer and terminate this monster attack
b9A68   JSR sA0D4		// delete character 3 data

j9A6B   JSR sA0DF		// Redraw 3 stats lines of characters in maze view footer

        LDA a0800		// Is there one character still alive ?
        CMP #$24		// If true, refresh view footer and process to next monster attack
        BNE j9A80		 
        JSR s9AF1		// else, run a long waiting loop...
        LDA #$00
        STA $D015    	// hide sprites
        JMP j8137		// return to game welcome screen

// refresh view footer and process to next monster attack
j9A80   JSR sA0DF		// Redraw 3 stats lines of characters in maze view footer
        JSR s9AF1		// Long waiting loop...
b9A86   INC a7A			// increment monster index
        LDX a7A			// have all monsters been processed ?
        CPX a74
        BEQ b9A9C		// if so, loop to party engage
        LDA f6000,X		// load HP of current monster
        BEQ b9A86		// if current monster is dead, skip it
        JSR sA347		// Reset message window and cursor
        JSR s9C7A		// check 'E' key for fight escape (if success, subroutine shortcuts fight)
        JMP b995A

b9A9C   JMP b9668		// loop to party engage

//////////////////////////////////
// Compute fight engage when party 
// tries to escape while fighting
// Monsters have then a bonus...
//////////////////////////////////
s9A9F   LDA a74			// load number of monsters
        ASL 			// multiply by 2
        STA a45			// store as 'monster attack bonus'
        JMP j9AAB		// compute fight engage value (return value in ACC)

///////////////////////////////
// Compute fight engage.
// Return : 
// $64 if monster engages
// $00 if party engages
///////////////////////////////
s9AA7   LDA #$00		// reset 'other monster bonus'
        STA a45			
j9AAB   LDA a0812		// Load Dexterity of first character
        STA a73
        LDA a0900		// Is there a second character ?
        CMP #$24
        BEQ b9ACE
        LDA a0912		// If true, add Dexterity of second character
        CLC 
        ADC a73
        STA a73
        LDA a0A00		// Is there a third character ?
        CMP #$24
        BEQ b9ACE
        LDA a0A12		// If true, add Dexterity of third character
        CLC 
        ADC a73
        STA a73			
b9ACE   LDX a88			// Load monster ID in X
        LDA a73			// Load sum of characters Dexterity in ACC
        SEC 
        SBC fA470,X		// if monster attack bonus > sum dext, monster engage
        BCC b9AEB		
        SBC a84			// substract current level (floor)
        BCC b9AEB		// if attack bonus + level > sum dext, monster engage
        SBC a45
        BCC b9AEB		// if attack bonus + level + 'other bonus ?' > sum dext, monster engage
        STA a73
        LDA $D41B    	// get a random value in range 0..63
        AND #$3F
        CMP a73			// is (sum dext - monster attack bonus - level - 'other bonus') > random (0..63) ?
        BCC b9AEE		// if true, party engages
b9AEB   LDA #$64		// else monster engage
        RTS 

b9AEE   LDA #$00		
        RTS 

///////////////////////
// Long waiting loop...
///////////////////////
s9AF1   JSR s9C62		// waiting loop
        JSR s9C62		// waiting loop
        JSR s9C62		// waiting loop
        JSR s9C62		// waiting loop
        JSR s9C62		// waiting loop
        RTS 

////////////////////////////////////////
// Display gold loot and experience gain
// in message window
////////////////////////////////////////
j9B01   JSR s9AF1		// Long waiting loop...
        JSR sA347		// Reset message window and cursor
		
// Compute gold gained
// Display bytes 10,18,15,0D,2A,24 that matches string "GOLD: " at in message window
        LDA #$38
        STA a87
        JSR s84A7		// Display a string at offset $A6A7+($87), starting on next row of message windows (column 22)
        LDY #$00		// Set MSB of value to display to 0
        STY a76
        STY a6F
        STY a3B
        LDA #$FF		// Modify trigger of current square : put $FF in north coordinate to deactivate it
        STA (p66),Y
        LDX a88			// load monster ID
        LDA fA498,X		// get gold gain for this monster ID
        ASL 			// multiply by 2
        STA a39			// Save gold gain at $39
        STA a75			// Set gold value in LSB of word to display
        JSR sA1ED		// Display word value stored in ($75).w
		
// Display bytes 0E,21,19,0E,1B,12,0E,17,0C,0E,2A,24 that matches string "EXPERIENCE: " at in message window		
        JSR s84A7		// Display a string at offset $A6A7+($87), starting on next row of message windows (column 22)
        LDX a88			// load monster ID
        CPX #$27		// Balrog ?
        BNE b9B3F
        LDA #$08		// If true, store $2008 in $75.w (word to display)
        STA a75			// and also at $6E.w (experience gained)
        STA a6E
        LDA #$20
        STA a76
        STA a6F
        JMP j9B7B		// display experience gained value in message window

// Compute experience gain for this monster
b9B3F   LDA fA470,X		// get attack bonus for this monster ID
        ASL 			// multiply by 16
        ASL 
        ASL 
        ASL 
        STA a7A
        LDX a74			// load counter with number of monsters
j9B4A   CPX #$00		// multiply experience gain by (monsters number + 1)
        BEQ b9B59
        CLC 
        ADC a7A			
        BCC b9B55
        INC a6F			// increment experience gain MSB at $6F if addition overflows
b9B55   DEX 
        JMP j9B4A

// Divide experience gained by 2 for a 2 characters team,
// or by 4 for a 3 characters team
b9B59   STA a6E			// store experience gain LSB at $6E
        LDA #$09		// let ($3B).w point to second character data
        STA a3C
b9B5F   LDY #$00		// is there a character in current slot ?
        LDA (p3B),Y
        CMP #$24
        BEQ b9B73		// if not, store experience gained at $75.w for display
        LSR a6F			// if there is a second character, divide experience gain by 2
        ROR a6E
        INC a3C			// let ($3B).w point to next character data
        LDA a3C
        CMP #$0B		// if all characters processed, display experience gained
        BNE b9B5F
b9B73   LDA a6F			// store experience gained in word to display at $75.w
        STA a76
        LDA a6E
        STA a75
		
// Display experience gained value
j9B7B   JSR sA1ED		// Display word value stored in ($75).w

// If the balrog just died, 
// Display bytes 0C,18,17,10,1B,0A,1D,1E,15,0A,1D,12,18,17,1C,25,0B,1E,1D,24,1D,11,0E,24,0B
// 0A,1D,1D,15,0E,24,24,10,18,0E,1C,24,18,17,26,24,1C,0E,0E,14,24,24,24,11,12,1C,24,0A,15,15
// 12,0E,1C,24,12,17,24,24,24,0A,0D,1F,0E,17,1D,1E,1B,0E,24,02,2A,24,24,24,24,1C,11,0A,0D,18,20
// 24,1C,17,0A,1B,0E,24,24,24,24
// that matches string "CONGRATULATIONS,BUT THE BATTLE  GOES ON. SEEK   HIS ALLIES IN   ADVENTURE 2:    SHADOW SNARE    " 
// in message window	
        LDA a88			// Is the balrog dead ?
        CMP #$27
        BNE b9BA1
        JSR sA36B		// Two line returns in message window and reset X
        LDY #$00
j9B89   LDA fB480,Y
        BEQ b9B9E
        JSR s9E94		// Output char in AC
        LDA a49			// if max column of message window reached,
        CMP #$26
        BNE b9B9A
        JSR sA36D		// One line return in message window and reset X
b9B9A   INY 
        JMP j9B89

b9B9E   JSR s8846		// Play gong signal

// add gold and experience gains to character data
b9BA1   LDA #$08		// let $3B.w point to first character data
        STA a3C
b9BA5   LDY #$00
        LDA (p3B),Y		// is there one character in current slot
        CMP #$24		// if not, loot has been assign to character
        BEQ j9BDD		// hide monsters sprites and return to maze view
// add looted gold
        LDY #$15		// else add gold gain
        LDA a39			// load gold gain
        CLC 
        ADC (p3B),Y		// add it to character gold LSB
        STA (p3B),Y
        LDA #$00
        INY 
        ADC (p3B),Y		// add carry to character gold MSB
        BCC b9BBF		// if MSB overflows
        LDA #$FF		// set it to a maximum of $FF
b9BBF   STA (p3B),Y
// add experience gain
        LDY #$1E
        LDA a6E			// load experience gained LSB
        CLC 
        ADC (p3B),Y		// add it to LSB of character tmp experience
        STA (p3B),Y
        LDA a6F			// load experience gained MSB
        INY 
        ADC (p3B),Y		// add it to MSB of character tmp experience
        BCC b9BD3		// if MSB overflows
        LDA #$FF		// set it to a maximum of $FF
b9BD3   STA (p3B),Y
        INC a3C			// let $3B.w point to next character data
        LDA a3C
        CMP #$0B		// are all characters processed ?
        BNE b9BA5		// if not, loop on next character
		
j9BDD   LDA #$00		// Hide monster sprites
        STA $D015    	
        INC a83			// set message in window flag
        JSR s8DB1		// Draw 3D view content
        JMP b869E		// loop on keyboard read when in maze

////////////////////////////////////////////
// Deactivate wandering monsters according 
// to party level and maze floor number.
//
// If the sum of character level is lower than
// the level threshold, wandering monsers are
// activated :
// floor 0 : $00 (sum xp < 1024)
// floor 1 : $05 (sum xp < 5120)
// floor 2 : $0B (sum xp < 11264)
// floor 3 : $12 (sum xp < 18432)
// floor 4 : $1A (sum xp < 26624)
////////////////////////////////////////////
s9BEA   LDA a0818			// load first character experience MSB, and divide by 4
        LSR 
        LSR 
        STA a73
		
        LDA a0900			// is there a second character ?
        CMP #$24
        BEQ b9C17			
        LDA a0918			// if true, load second character experience MSB, and divide by 4
        LSR 
        LSR 
        CLC 
        ADC a73				// and add it to previous computed value
        STA a73
        BCS b9C20			// ?? how could the carry be set ??
		
        LDA a0A00			// is there a second character ?
        CMP #$24
        BEQ b9C17
        LDA a0A18			// if true, load third character experience MSB, and divide by 4
        LSR 
        LSR 
        CLC 
        ADC a73				// and add it to previous computed value
        STA a73
        BCS b9C20			// ?? how could the carry be set ??
		
b9C17   LDX a84				// chargement du niveau actuel (0..4)
        LDA fA3E6,X
        CMP a73
        BCS b9C25
b9C20   LDA #$64			// deactivate wandering monsters
b9C22   STA a80
        RTS 

b9C25   LDA #$00			// activate wandering monsters
        BEQ b9C22

//////////////////////////////////////////////////
// Modifie les couleurs du logo MAZE MASTER en jeu
// RED foreground on WHITE background
//////////////////////////////////////////////////
s9C29   LDA #$21			// color of logo zone : RED foreground on WHITE background
        STA a89
j9C2D   LDA #$00			// initialize screen ram pointer ($FB).w=$0400
        STA a3D				// reset de l'index de ligne courante
        STA aFB
        LDA #$04
        STA aFC
        LDY #$14			// start at column 20
b9C39   LDX #$00			// compteur du nombre de blocs modifiés
b9C3B   LDA a89				// load foreground/background colors from $89
        STA (pFB),Y
        INY 
        BNE b9C44
        INC aFC
b9C44   INX 
        CPX #$14			// 20 blocs modifiés ?
        BNE b9C3B			// si non, alors modifie le prochain bloc
        TYA 				// si oui, on saute les 20 prochains blocs
        CLC 
        ADC #$14
        TAY 
        BCC b9C52
        INC aFC
b9C52   INC a3D				// increment de la ligne courante
        LDA a3D
        CMP #$04			// 4 lignes modifiées ?
        BNE b9C39			// si non, on boucle sur la modification des couleurs
        RTS 				// si oui, la modification est terminée

//////////////////////////////////////////////////
// Modifie les couleurs du logo MAZE MASTER en jeu
// WHITE foreground on RED background
//////////////////////////////////////////////////
s9C5B   LDA #$12
        STA a89
        JMP j9C2D

//////////////////////////////////////
// Waiting loop (65536 iterations)
// It lasts 352788 cpu cycles = 358 ms
//////////////////////////////////////
s9C62   LDX #$00
        LDY #$00
b9C66   INX 
        BNE b9C66
        INY 
        BNE b9C66
        RTS 

////////////////////////////////////////////////
// Invert temporarily colors of MAZE MASTER logo
//////////////////////////////////////////////// 
s9C6D   JSR s9C5B		// WHITE logo on RED background
        JSR s9C62
        JSR s9C29		// RED logo on WHITE background
        JSR s9C62
        RTS 

////////////////////////////////////////////////////
// Infight escape
// Check keyboard for 'E' key pressed (escape)
// It the check for monsters engage and if it fails,
// party achieves to run away...
// Note : key pressed test is performed only once out
// of 6 calls (!?)
////////////////////////////////////////////////////
s9C7A   LDA a35
        BEQ b9C81
        DEC a35
b9C80   RTS 

b9C81   JSR $FFE4    	// Read key press       
        CMP #$45		// 'E' key pressed ?
        BNE b9C80		// if not, exit subroutine
        LDA #$06		// else 
        STA a35
        JSR s9A9F		// Compute fight engage with a bonus for monsters
        BNE b9C80		// if monsters engage exit subroutine
        JSR sA347		// Reset message window and cursor
        PLA 
        PLA 
        JMP j9624		// Party goes away and terminate fight

/////////////////////////
// Display menu HEADER //
/////////////////////////

// Display round corner char at (9,0)
s9C99   LDA #$09		// Column 9
        STA a49
        LDA #$00		// Row 0
        STA a4A
        LDA #$2C		// Caracter = round angle, lower right
        JSR s9E94		// Output char in AC
		
// Display '-' char at (10,0)->(29,0)
        LDX #$00		// Initialize char counter
b9CA8   LDA #$29
        JSR s9E94		// Output char in AC
        INX 
        CPX #$14
        BNE b9CA8

// Display round corner char at (30,0)
        LDA #$2D
        JSR sA388   	// Write char from AC, and return to next line, column 9
        
// Display '|' at (9,1)
		LDA #$2B
        JSR s9E94		// Output char in AC
		
// Display 12 chars at (14,1), stored at $A5B2 : " MAZE " (each screen char use 2 RAM char)
		LDA #$0E
        STA a49
        LDX #$02
b9CC2   LDA fA5B0,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0E
        BNE b9CC2
		
// Display '|' at (30,1)
        LDA #$1E
        STA a49
        LDA #$2B
        JSR sA388		// Write char from AC, and return to next line, column 9
        
// Display '|' at (10,2)
		LDA #$2B
        JSR s9E94		// Output char in AC
		
// Display 12 chars at (14,2), stored at $A5C2 : " MASTER " (each screen char use 2 RAM char)
        LDA #$0E
        STA a49
        LDX #$02
b9CE1   LDA fA5C0,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0E
        BNE b9CE1
		
// Display '|' at (30,2)
        LDA #$1E
        STA a49
        LDA #$2B
        JSR sA388		// Write char from AC, and return to next line, column 9
		
// Ouput screen codes 2B,0B,22,24,16,12,0C,11,0A,0E,15,24,0C,1B,0A,17,0F,18,1B,0D,24,2B at (9,3)
// that matches chars "|BY MICHAEL CRANFORD |"
        LDX #$00
b9CF7   LDA fA5D0,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$16
        BNE b9CF7
        JSR sA38B		// return to next line, column 9
		
// Display round corner char at (9,4)
        LDA #$2E
        JSR s9E94		// Output char in AC
		
// Display '-' char at (10,4)->(29,4)
        LDX #$00
b9D0C   LDA #$29
        JSR s9E94		// Output char in AC
        INX 
        CPX #$14
        BNE b9D0C
		
// Display round corner char at (30,4)
        LDA #$2F
        JSR s9E94		// Output char in AC
        JSR sA38B		// return to next line, column 9
		
// Ouput screen codes 0C,18,19,22,1B,12,10,11,1D,24,4A,0C,28,24,01,09,08,03,24,11,0E,1C at (9,5)
// that matches chars "COPYRIGHT (C) 1983 HES"
        LDX #$00
b9D20   LDA fA9C3,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$16
        BNE b9D20
        RTS 

//////////////////////////
//  Display menu FOOTER //
//////////////////////////

// Display round corner char at (9,18)
s9D2C   LDA #$12
        STA a4A
        LDA #$09
        STA a49
        LDA #$2C
        JSR s9E94		// Output char in AC
		
// Display '-' char at (10,18)->(30,18)
        LDX #$00
b9D3B   LDA #$29
        JSR s9E94		// Output char in AC
        INX 
        CPX #$15
        BNE b9D3B
		
// Display round corner char at (31,18)
        LDA #$2D
        JSR sA388		// Write char from AC, and return to next line, column 9

// Display '|' at (9,19)
        LDA #$2B
        JSR s9E94		// Output char in AC
		
// Ouput screen codes 0C,11,0A,1B,0A,0C,1D,0E,1B,24,17,0A,16,0E at (14,19)
// that matches chars "CHARACTER NAME"
        LDX #$00
        LDA #$0E
        STA a49
b9D55   LDA fA5E6,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0E
        BNE b9D55
		
// Display '|' at (31,19)
        LDA #$1F
        STA a49
        LDA #$2B
        JSR sA388		// Write char from AC, and return to next line, column 9
		
// Ouput screen codes 2B,24,01,28 at (9,20)
// that matches chars "| 1)"
        LDX #$00
b9D6B   LDA fA5F4,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$04
        BNE b9D6B
		
// Display 15 chars at (14,20), stored at $0800 : character 1 name
        INC a49
        LDX #$00
b9D7A   LDA a0800,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$10
        BNE b9D7A
		
// Display '|' at (31,20)
        INC a49
        LDA #$2B
        JSR sA388		// Write char from AC, and return to next line, column 9
		
// Ouput screen codes 2B,24,02,28 at (9,21)
// that matches chars "| 2)"
f9D8C   LDX #$04
b9D8E   LDA fA5F4,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$08
        BNE b9D8E
		
// Display 15 chars at (14,21), stored at $0900 : character 2 name
        INC a49
        LDX #$00
b9D9D   LDA a0900,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$10
        BNE b9D9D

// Display '|' at (31,21)
        INC a49
        LDA #$2B
        JSR s9E94		// Output char in AC
        INC a4A
        LDA #$09
        STA a49
		
// Ouput screen codes 2B,24,03,28 at (9,22)
// that matches chars "| 3)"		
        LDX #$08
b9DB7   LDA fA5F4,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0C
        BNE b9DB7
		
// Display 15 chars at (14,22), stored at $0A00 : character 3 name
        INC a49
        LDX #$00
b9DC6   LDA a0A00,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$10
        BNE b9DC6
		
// Display '|' at (31,22)
        INC a49
        LDA #$2B
        JSR sA388		// Write char from AC, and return to next line, column 9

// Display round corner char at (9,23)
        LDA #$2E
        JSR s9E94		// Output char in AC
		
// Display '-' char at (10,23)->(30,23)
        LDX #$00
b9DDF   LDA #$29
        JSR s9E94		// Output char in AC
        INX 
        CPX #$15
        BNE b9DDF
        
// Display round corner char at (31,23)
		LDA #$2F
        JSR s9E94		// Output char in AC
        RTS 

///////////////////////////////////////////////////////////////////////
// CLEAR SCREEN de la partie centrale du menu principal
//
// RAZ de la memoire de $2740 -> $362F
// soit 3888 octets, soit 486 (3888/8) blocks de 8x8 pixels bitmap,
// soit 12 lignes écran (486/40)
///////////////////////////////////////////////////////////////////////
s9DEF   LDA #$27		// on commence la RAZ à l'adresse $2700 ($2000+$700=$2000+1792=$2000+8*5*40)
        STA aFC			// soit la 5 ligne de l'écran bitmap
        LDA #$00
        STA aFB
        LDY #$40        // On initialise l'offset a 64 (8 chars)
b9DF9   LDA #$00
        STA (pFB),Y
        INY 
        BNE b9DF9
        INC aFC
        LDA aFC
        CMP #$36
        BNE b9DF9
b9E08   LDA #$00
        STA (pFB),Y
        INY 
        CPY #$30
        BNE b9E08
        RTS 

///////////////////////////////////////////////////////////////////////
// Affichage de la partie centrale du menu principal (choix 1,2,3,4)
///////////////////////////////////////////////////////////////////////
s9E12   LDA #$07
        STA a4A
        LDA #$05
        STA a49
        LDA #$2C
        JSR s9E94		// Output char in AC
        LDX #$00
b9E21   LDA #$29
        JSR s9E94		// Output char in AC
        INX 
        CPX #$1C
        BNE b9E21
        LDA #$2D
        JSR s9E94		// Output char in AC
        JSR sA392		// Return to next line, column 5
        LDX #$00
		
b9E35   LDA fA600,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$11
        BNE b9E35
        LDA #$22
        STA a49
        LDA #$2B
        JSR s9E94		// Output char in AC
        INC a4A
        DEC a49
        LDA #$2B
        JSR s9E94		// Output char in AC
        LDA #$05
        STA a49
        LDA #$2B
        JSR s9E94		// Output char in AC
        JSR sA392		// Return to next line, column 5
        LDY #$00
        LDX #$00
		
b9E62   LDA fA611,X
        JSR s9E94		// Output char in AC
        INY 
        INX 
        CPY #$1E
        BNE b9E62
        LDY #$00
        JSR sA392		// Return to next line, column 5
        CPX #$96
        BNE b9E62
        LDA #$2E
        JSR s9E94		// Output char in AC
        LDX #$00
b9E7E   LDA #$29
        JSR s9E94		// Output char in AC
        INX 
        CPX #$1C
        BNE b9E7E
        LDA #$2F
        JSR s9E94		// Output char in AC
        RTS 

///////////////////////////////////////////////////////////////
// Lit une touche du clavier et renvoie le code petscii dans AC
///////////////////////////////////////////////////////////////
s9E8E   JSR $FFE4    ;ROM_GETIN  - get a byte from channel          
        BEQ s9E8E
        RTS 

/////////////////////////////////
// Dispay some text on screen
//
// param : ($49)= x coordinate ?
// param : ($4A)= y coordinate ?
// A : character number
/////////////////////////////////
s9E94   STX a73				// save X
        STY a45				// save Y
		
// Load LSB of offset for character data number 'A' in RAM
        TAX 
        LDA f5100,X
        STA aFD
// Load MSB of offset for character data number 'A' in RAM
        LDA f5200,X
        CLC 
// Add $4000 to this offset (CHARSET location in RAM)
        ADC #$40
        STA aFE

        LDA #$20			// Load MSB of bitmap start address
        CLC 
        LDX a4A
        ADC fA4E8,X			// add MSB of bitmap address offset relative to $20) of first 8x8 block at screen row Y
        STA aFC

        LDA f5000,X			// load LSB of bitmap address of first 8x8 block at screen row Y
        STA aFB
        BCC b9EB9			// ?? Carry is always clear here...
        INC aFC
b9EB9   LDX a49
        LDA f5200,X			// load MSB offset for this column relative to first address on this row
        CLC 
        ADC aFC				// add it to the MSB of address for the first block on this row
        STA aFC
        LDA f5100,X			// load LSB offset for this column relative to first address on this row
        CLC 
        ADC aFB				// add it to the LSB of address for the first block on this row
        STA aFB
        BCC b9ECF			// Page overflow ?
        INC aFC				// Increase MSB
		
b9ECF   LDY #$00
b9ED1   LDA (pFD),Y	 		// Copy 8 bytes from ($FD).w->($FB).w
        STA (pFB),Y  		// i.e from custom RAM charset to bitmap memory
        INY 
        CPY #$08
        BNE b9ED1
        INC a49
        LDX a73				// restore X
        LDY a45				// restore Y
        RTS 

//////////////////////////////////////////////
// Draw characters footer in game view
// Draw maze master logo in top of message box
// Initialize sprites 0-3
//////////////////////////////////////////////
// Display footer of game view with characters attributes
// Ouput screen codes 0C,11,0A,1B,0A,0C,1D,0E,1B,24,17,0A,16,0E,24,24,24,0A,1B,16,24,0C,18,17,24
// 0C,17,0D,24,0C,15,0A,1C,1C at (3,21)
// that matches chars "CHARACTER NAME   ARM CON CND CLASS"		
s9EE1   LDA #$03		// column 3	
        STA a49
        LDA #$15		// row 21
        STA a4A
        LDX #$00
b9EEB   LDA fA58D,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$22
        BNE b9EEB

        JSR sA0DF		// Redraw 3 stats lines of characters in maze view footer
		
// Display maze master logo in top of message window
        LDA #$16		// Column 22
        STA a49
        LDA #$00		// row 0
        STA a4A
        LDA #$2C		// load character 'round corner lower right'
        JSR s9E94		// Output char in AC
        LDX #$00
b9F08   LDA #$29		// load character '-'
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0E		// 14 chars '-' displayed ?
        BNE b9F08		// if not, keep on displaying
        LDA #$2D		// else load character 'round corner lower left'
        JSR s9E94		// Output char in AC
        JSR sA36D		// One line return in message window and reset X
// display the upper part '|   MAZE   |' of maze master logo
b9F1A   LDA fA5B0,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$10
        BNE b9F1A
        JSR sA36D		// One line return in message window and reset X
		
// display the lower part '|  MASTER  |' of maze master logo
b9F28   LDA fA5C0,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$10
        BNE b9F28
        JSR sA36D		// One line return in message window and reset X

        LDA #$2E		/ load character 'round corner upper right'
        JSR s9E94		// Output char in AC
b9F3B   LDA #$29		// load character '-'
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0E		// 14 chars '-' displayed ?
        BNE b9F3B		// if not, keep on displaying
        LDA #$2F		// else load character 'round corner upper left'
        JSR s9E94		// Output char in AC
		
        LDA #$01		// Load WHITE color
        STA $D027    	// Set solid color of Sprite 0
        STA $D028    	// Set solid color of Sprite 1
        STA $D029    	// Set solid color of Sprite 2
        STA $D02A    	// Set solid color of Sprite 3
        LDA #$0F
        STA $D017    	// Activate doubled height for all 8 sprites
        STA $D01C    	// Activate Multi-Color Mode for all 8 sprites
        STA $D01D    	// Activate doubled width for all 8 sprites
		
// The sprite pointers are the 8 bytes at the end of the screen memory (0400 – 0800)
        LDX #$3C		// First sprite data is located at $F00 (=$3C*$40)
        STX a07F8
        INX 			// Second sprite data is located at $F40 (=$3D*$40)
        STX a07F9
        INX 			// Third sprite data is located at $F80 (=$3E*$40)
        STX a07FA
        INX 			// Fourth sprite data is located at $FC0 (=$3F*$40)
        STX a07FB
		
// Sprites positions : 0 at (56,88), 1 at (104,88), 2 at (56,130), 3 at (104,130)
        LDA #$38
        STA $D000    	// Sprite 0 X Pos
        STA $D004    	// Sprite 2 X Pos
        LDA #$68
        STA $D006    	// Sprite 3 X Pos
        STA $D002    	// Sprite 1 X Pos
        LDA #$58
        STA $D001   	// Sprite 0 Y Pos
        STA $D003   	// Sprite 1 Y Pos
        LDA #$82
        STA $D005   	// Sprite 2 Y Pos
        STA $D007    	// Sprite 3 Y Pos
		
        LDA #$00
        STA $D010    	// Sprites 0-7 MSB of X coordinate
		
// Hide all 8 sprite (for now...)
        STA $D015    	// Sprite display Enable
        RTS 

////////////////////////////////////////////
// Convert a decimal value from input buffer
// into a word at ($75).w
////////////////////////////////////////////
s9F9D   LDA #$00
        STA a75			// reset result LSB
        STA a76			// reset result MSB
        STX a73			// store last char index of buffer in $73
        LDY #$00
j9FA7   LDA fA414,Y		// read LSB of 1 unit in base 10 lookup table
        STA a45
        LDA fA40C,Y		// read MSB of 1 unit in base 10 lookup table
        STA a46
        LDX a73			// end of buffer ?
        CPX #$FF			
        BEQ b9FC5		// return for subroutine
        LDA f0B00,X		// get character from input buffer at index X
        TAX 
        CPX #$0A		// ensure char is 0..9
        BCC b9FC6		
        LDA #$00		// else result is 0
        STA a75
        STA a76
b9FC5   RTS 

b9FC6   CPX #$00		// if char is 0, stop adding value for current index buffer position
        BEQ b9FDB
        LDA a75			// load result LSB
        CLC 
        ADC a45			// add LSB matching a unit value at digit indexed Y (in base 10)
        STA a75			
        LDA a76			// load result MSB
        ADC a46			// add MSB matching a unit value at digit indexed Y (in base 10)
        STA a76
        DEX 			// decrement digit at current position of buffer
        JMP b9FC6		// keep on processing digit at current position of buffer

b9FDB   INY 			// digit at current position of buffer is now zero
        DEC a73			// go to the previous position in buffer (and increment base 10 lookup table)
        JMP j9FA7
		
///////////////////////////////////////////
// Terminate keyboard read into buffer 
// 
// return : nb of input chars in X register
///////////////////////////////////////////
j9FE1   LDX a3D
        CPX #$00
        BEQ bA01B
        DEX 
        LDA #$24
        JSR s9E94		// Output char in AC
        RTS 

//////////////////////////////////////
// Lit 9 caracteres  depuis le clavier
//////////////////////////////////////
s9FEE   LDA #$09
        STA a3A
        JMP jA007

//////////////////////////////////////
// Lit 7 caracteres  depuis le clavier
//////////////////////////////////////
s9FF5   LDA #$07
        STA a3A
        JMP jA007

//////////////////////////////////////
// Lit 3 caracteres  depuis le clavier
//////////////////////////////////////
s9FFC   LDA #$03
        STA a3A
        JMP jA007

////////////////////////////////////////////////////////////
// Lecture du clavier (10 chars) avec validation par 'enter'
// ou remplissage complet du buffer.
//
// Ecriture du tampon dans $0B00 (10 chars)
// return : nb of input chars in X register
////////////////////////////////////////////////////////////
sA003   LDA #$10
fA005   STA a3A
/////////////////////////////////////////////////////
// Lecture du clavier avec validation par 'enter'
// ou remplissage complet du buffer
//
// Ecriture du tampon dans $0B00 (nb chars dans $3A)
// return : nb of input chars in X register
/////////////////////////////////////////////////////
jA007   LDA #$00
        STA a3D			// current char index in write buffer
        STA a85			// counter for a waiting loop
        STA a87			// reset cursor counter (0..3)
        LDX #$00

// Fill input buffer with space char ' '
bA011   LDA #$24
        STA f0B00,X
        INX 
        CPX a3A
        BNE bA011
		
bA01B   JSR $FFE4    	// ROM_GETIN  - get a byte from channel          
        BNE bA04F		// Key pressed ?
        INC a85
        LDA a85
        BNE bA032
        INC a87
        LDA a87
        CMP #$04		// if cursor counter reaches 4, make it loop to 0
        BNE bA032
        LDA #$00
        STA a87
bA032   LDA a87
        CMP #$02		// cursor counter < 2, display blank cursor
        BCS bA042		// else display plain
		
// Display plain cursor
        LDA #$48		
        JSR s9E94		// Output char in AC
        DEC a49			// return to previous column (because previous call increment col), for blink
        JMP bA01B		// loop on input read

// Display blank cursor
bA042   LDA #$24
        JSR s9E94		// Output char in AC
        DEC a49			// return to previous column (because previous call increment col), for blink
bA049   JMP bA01B		// loop on input read

// Validate line
bA04C   JMP j9FE1

bA04F   CMP #$14		// 'Delete' key pressed ?
        BEQ bA084
        CMP #$0D		// 'Enter' key pressed ?
        BEQ bA04C
        CMP #$20		// 'Space' key pressed ?
        BEQ bA070
        SEC 
        SBC #$30
        CMP #$0A
        BCC bA072
        SEC 
        SBC #$07
        CMP #$0A
        BCC bA049
        CMP #$24
        BCC bA072
        JMP bA01B		// loop on input read

// Space pressed ?
bA070   LDA #$24
bA072   LDX a3D			// Store ' ' char in buffer
        STA f0B00,X
        JSR s9E94		// Output char in AC
        INX 			// increment buffer index position
        STX a3D
        CPX a3A			// buffer full ?
        BEQ bA04C		// 
        JMP bA01B		// loop on input read

// 'Delete' key pressed
bA084   LDX a3D			// If pressed with an empty buffer, loop on input read
        CPX #$00
        BEQ bA049
        DEX 			// else, decrease char position
        LDA #$24		// write space char ' ' in buffer
        STA f0B00,X		// and display space ' ' at current position (to clear cursor)
        JSR s9E94		// Output char in AC
        DEC a49			// return to previous column (to remove ' ' space)
        STX a3D			// update current char index
        DEC a49			// return to previous column (to remove previous char)
        JMP bA01B		// loop on input read

///////////////////
// ?? DEAD CODE ??
//////////////////
        LDA #$07
        STA a49
        LDX a86
jA0A2   LDA fA6A7,X
        CMP #$FF
        BEQ bA0B0
        JSR s9E94		// Output char in AC
        INX 
        JMP jA0A2

bA0B0   INX 
        STX a86
        JSR sA003		// Read 10 characters (max) from keyboard
        JSR s9F9D		// Convert a decimal value from input buffer into ($75).w
        LDA a75			// Load converted value
        INC a4A			// next row
        RTS 

////////////////////////
// Delete character 1 //
////////////////////////
// Copy all character 2 data to character 1 slot
sA0BE   LDX #$00
bA0C0   LDA a0900,X
        STA a0800,X
        INX 
        BNE bA0C0
////////////////////////
// Delete character 2 //
////////////////////////
// Copy all character 3 data to character 2 slot
sA0C9   LDX #$00
bA0CB   LDA a0A00,X
        STA a0900,X
        INX 
        BNE bA0CB
////////////////////////
// Delete character 3 //
////////////////////////
// Fill all character 3 data with space ' '
sA0D4   LDX #$00
bA0D6   LDA #$24
        STA a0A00,X
        INX 
        BNE bA0D6
        RTS 

/////////////////////////////////////////////////////////
// Redraw 3 stats lines of characters in maze view footer
/////////////////////////////////////////////////////////
sA0DF   LDA #$08		// initialize character data pointer
        STA a3C
        LDA #$00
        STA a3B
        LDA #$16		// row 22
        STA a4A
        LDA #$3B		// ($FB).w = $3B80 (bitmap memory)
        STA aFC
        LDA #$80
        STA aFB
        LDY #$00		// Fill $3B80-$3C7F with 0 (rows 22-24)
bA0F5   LDA #$00
        STA (pFB),Y
        INY 
        BNE bA0F5		// If no page overflow, loop on fill
        INC aFC			// increment MSB of pointer
        LDA aFC
        CMP #$3F		// $3F80 reached ?
        BNE bA0F5		// if not, loop on fill. Else bitmap area is cleared
		
jA104   LDA #$00		// column 0
        STA a49
        LDY #$00		// load name of first character
        LDA (p3B),Y
        CMP #$24		// empty slot ?
        BNE bA111		// if true, exit subroutine
        RTS 

// Display character number
bA111   LDA a3C				// compute character number (1..3)
        SEC 
        SBC #$07
        JSR s9E94		// Output char in AC
        LDA #$28		// load ')' char
        JSR s9E94		// Output char in AC
        INC a49			// skip 1 column

// Display character name
bA120   LDA (p3B),Y		// load one character name char
        JSR s9E94		// Output char in AC
        INY 
        CPY #$10		// 10 name chars displayed ?
        BNE bA120		// if not, loop
        INC a49			// skip 1 column
		
// Compute and display character armor (the lower, the better)
// Once computed, value is store at offset $20 of character data
        LDY #$1A		// get character armor
        LDA (p3B),Y
        TAX 
        LDY #$20
        LDA fA3F0,X		// get armor rating for this item (14,11,0E,0B,08)
        STA (p3B),Y		// store value at character data offset $20
        STA a47			// store also at $47
        LDY #$1B		// get character shield
        LDA (p3B),Y
        TAX 
        LDA a47
        SEC 
        SBC fA3EB,X		// substract shield armor rating from current armor rating (0,1,2,3,4)
        LDY #$20
        STA (p3B),Y		// store value at character data offset $20	
        LDY #$12		// load character dexterity
        LDA (p3B),Y
        JSR sA376		// Compute X=A-$0F, if X>$0F (bonus for high stat)
        STX a47			// store dexterity armor bonus (1 for 16 ... 3 for 18)
        LDY #$20		// load current armor rating
        LDA (p3B),Y
        SEC 
        SBC a47			// substract dexterity bonus
        SEC 
        SBC a704E		// substract magic armor bonus 
        BCS bA161		// ensure armor rating is >= 0
        LDA #$00
bA161   STA (p3B),Y		// update character armor rating
        LDY #$1C		// get magical item of character
        LDA (p3B),Y
        CMP #$04		// is it a Hawk blazon ?
        BNE bA171		
        LDA #$00		// if true, set armor rating to 0
        LDY #$20		// update character armor rating
        STA (p3B),Y
bA171   LDY #$20		// reload armor rating
        LDA (p3B),Y
        STA a47			// store at $47
        LDX #$4B		// load char '+'
        STX a46			// store at $46
        CMP #$0A		// is armor rating >= 10 ?
        BCS bA18D		
        LDA #$49		// if not, load char '-'
        STA a46			// store at $46
        LDA #$0A		// initialize displayed armor rating at 10
        SEC 
        SBC a47			// substract armor rating
        STA a47			// store at $47
        JMP jA192

bA18D   SEC 
        SBC #$0A		// substract 10 to armor rating
        STA a47			// store at $47
jA192   LDA a46			// load '+' or '-' char
        JSR s9E94		// Output char in AC
        LDA a47			// load armor rating to display
        STA a75			// store it as LSB of word to display
        LDA #$00		// set MSB of word to display at 0
        STA a76	
        JSR sA1ED		// Display word value stored in ($75).w

// Display character constitution	
        LDA #$18		// column 24
        STA a49
        LDY #$13		// load character constituion
        LDA (p3B),Y
        STA a75			// store it as LSB of word to display
        LDA #$00		// set MSB of word to display at 0
        STA a76
        JSR sA1ED		// Display word value stored in ($75).w
		
// Display character condition	
        LDA #$1C		// column 25
        STA a49
        LDY #$1D		// load character condition
        LDA (p3B),Y
        STA a75			// store it as LSB of word to display
        JSR sA1ED		// Display word value stored in ($75).w

// Display character class (WAR or WIZ)		
        LDA #$21		// column 33
        STA a49
        LDX #$00
        LDY #$14		// load character class
        LDA (p3B),Y
        CMP #$01		// is he a warrior ?
        BEQ bA1D0		// if true text offset is 0
        LDX #$07		// if not, text offset is 7
bA1D0   LDA fA72C,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$03
        BEQ bA1DF
        CPX #$0A
        BNE bA1D0
		
bA1DF   INC a3C			// increment character data pointer MSB
        INC a4A			// increment row number
        LDA a3C			// load character data pointer MSB
        CMP #$0B		// last character processed ?
        BEQ bA1EC		// if true, return subroutine
        JMP jA104		// else, loop on displaying next character

bA1EC   RTS 

/////////////////////////////////////////////////////////
// Output a word decimal value at current cursor position
//
// Input : ($75).w = decimal value to display (0-65535)
// $75 : LSB of word value to display
// $76 : MSB of word value to display
/////////////////////////////////////////////////////////

// Clear memory at $702E-$7032
// $7032 contient la plus petite décimale
// $702E contient la plut haute décimale
sA1ED   LDX #$00
bA1EF   LDA #$00
        STA f702E,X
        INX 
        CPX #$05
        BNE bA1EF
		
// Tant que la valeur du MSB est non nulle, ajoute les valeurs
// 2,5 et 6 aux adresses $7030,$7031,$7032 (256=1<<8).
// A chaque passage dans la boucle, appelle la routine de réduction
// qui applique les retenues sur les decimales supérieures.
        LDY a76			// is MSB null ?
jA1FB   CPY #$00
        BEQ bA221		// If so, display only LSB
        DEY 			// Decrement MSB value
        LDA a7030		// Add $2 to $7030
        CLC 
        ADC #$02
        STA a7030
        LDA a7031		// Add $5 to $7031
        CLC 
        ADC #$05
        STA a7031
        LDA a7032		// Add $6 to $7032
        CLC 
        ADC #$06
        STA a7032
        JSR sA249		// Réduit la valeur décimale
        JMP jA1FB		// Boucle tant que le MSB est non nul...

bA221   LDY a75			// is LSB null ?
jA223   CPY #$00
        BEQ bA231		// If so, display decimals to current cursor location
        DEY 			// Else, decrement LSB value
        INC a7032		// increment lowest digit at $7032
        JSR sA249		// Réduit la valeur décimale
        JMP jA223		// Boucle tant que le LSB est non nul...

// Display at current cursor position digits matching decimal values stored
// at $702E-$7032
bA231   LDX #$00
bA233   LDA f702E,X		// Is current digit null ?
        BNE bA23D		// If not, display digit character
        INX 			// If null, skip this digit and process next
        CPX #$04		// Display last digit, even if it is null
        BNE bA233		// If not, keep on processing next digit
bA23D   LDA f702E,X		
        JSR s9E94		// Output char in AC
        INX 			// Process next digit
        CPX #$05		// Are all digit process ?
        BNE bA23D		// If not, keep on processing digits
        RTS 

////////////////////////////////////////////////////
// Réduit la valeur décimale stockée en $702E-$7032
// $7032 contient la plus petite décimale
// $702E contient la plut haute décimale
// Si une des adresses contient une valeur >10,
// incrémente la décimale supérieure et soustrait 10
// à la décimale courante.
////////////////////////////////////////////////////
sA249   LDX #$04
bA24B   LDA f702E,X
        CMP #$0A
        BCC bA25D
        SEC 
        SBC #$0A
        STA f702E,X
        DEX 
        INC f702E,X
        INX 
bA25D   DEX 
        CPX #$00
        BNE bA24B
        RTS 

///////////////////////////////
// Display character data sheet
///////////////////////////////
jA263   SEC 
        SBC #$29		// substract $29 from key pressed code
        STA a3C			// so that $3B.w points to selected character data
        LDY #$00
        STY a3B
        LDA (p3B),Y		// is there a character in this slot ?
        CMP #$24
        BNE bA275		// if true, display character data in message window
        JMP b869E		// if not, loop on keyboard read when in maze

// Display character name at (22,6)
bA275   JSR sA347		// Reset message window and cursor
        LDY #$00
bA27A   LDA (p3B),Y
        JSR s9E94		// Output char in AC
        INY 
        CPY #$10
        BNE bA27A

// Display chars '----------------' on next message window row (22,7)		
        JSR sA36D		// One line return in message window and reset X
bA287   LDA #$29
        JSR s9E94		// Output char in AC
        INX 
        CPX #$10
        BNE bA287
		
// Display string "STRENGTH: " on next message window row (22,8)	
        LDA #$06
        STA a87
        LDA #$00		// Clear MSB of word value to display
        STA a76
        JSR s84A7		// Display a string at offset $A6A7+($87).b, starting on next row of message window (column 22)
// Display strength value
        LDY #$10		// load strength value of character
        LDA (p3B),Y
        STA a75			// store in LSB of value to display
        JSR sA1ED		// Display word value stored in ($75).w
		
// Display string "INTELLECT: " on next message window row (22,9)	
        JSR s84A7		// Display a string at offset $A6A7+($87).b, starting on next row of message window (column 22)
// Display intellect value
        LDY #$11		// load intellect value of character
        LDA (p3B),Y
        STA a75			// store in LSB of value to display
        JSR sA1ED		// Display word value stored in ($75).w
		
// Display string "DEXTERITY: " on next message window row (22,10)	
        JSR s84A7		// Display a string at offset $A6A7+($87), starting on next row of message window (column 22)
// Display dexterity value
        LDY #$12
        LDA (p3B),Y
        STA a75
        JSR sA1ED		// Display word value stored in ($75).w

// Display string "GOLD: " on next message window row (22,11)
        LDA a87			// reload string offset
        CLC 
        ADC #$0F		// skip next string ("CONSTITUTION: ")
        STA a87
        JSR s84A7		// Display a string at offset $A6A7+($87), starting on next row of message windows (column 22)
// Load gold value
        LDY #$15		// load gold LSB
        LDA (p3B),Y
        STA a75			// store in LSB of value to display
		INY 
		LDA (p3B),Y		// load gold MSB
        STA a76			// store in MSB of value to display
        JSR sA1ED		// Display word value stored in ($75).w
		
// Display string "EXPERIENCE: " on next message window row (22,11)	
        JSR s84A7		// Display a string at offset $A6A7+($87), starting on next row of message windows (column 22)
// Load tmp experience value
        LDY #$1E		// load LSB of tmp experience
        LDA (p3B),Y
        STA a75			// store in LSB of value to display
        INY 
        LDA (p3B),Y		// load MSB of tmp experience
        STA a76			// store in MSB of value to display
        JSR sA1ED		// Display word value stored in ($75).w

// Ouput screen codes 12,1D,0E,16,1C,2A at (22,12) 
// that matches chars "ITEMS :"	
        JSR sA36D		// One line return in message window and reset X
        LDX #$04
bA2EB   LDA fA753,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0A
        BNE bA2EB
	
// For each item slot, display a blank line if no item is in slot
// else display item name	
        LDA #$18		// load item offset with first item offset - 1
        STA a87			// store item offset in character data at $87
bA2FA   JSR sA36D		// One line return in message window and reset X
        INC a87			// increment item offset	
        LDA a87
        CMP #$1D		// all items displayed ?
        BEQ bA328		// if true, keep on displaying spell points
        TAY 
        LDA (p3B),Y		// load item ID
        BEQ bA315		// no item ? display blank name and line return
jA30A   CPY #$19		// compute index in item name offset table
        BEQ bA315
        CLC 
        ADC #$04
        DEY 
        JMP jA30A

bA315   TAX 			// Load item ID in X. Items name offset are stored in a table store at $A42C.
        LDA fA42C,X		// Get name offset of current item
        TAX 
jA31A   LDA fBF00,X		// Display item name at address $BF00+offset, delimited with char $FF
        CMP #$FF		// If ending char of name reached, display next item
        BEQ bA2FA
        JSR s9E94		// Output char in AC
        INX 			// else display next item name char
        JMP jA31A		

// Ouput screen codes 1C,19,0E,15,15,24,19,1D,1C,2A,24 at (22,12) 
// that matches chars "SPELL PTS: "	
bA328   LDX #$00
bA32A   LDA fA771,X
        JSR s9E94		// Output char in AC
        INX 
        CPX #$0B
        BNE bA32A
		
        LDY #$21		// Load character spell points
        LDA (p3B),Y
        STA a75			// store in LSB of word value to display
        LDA #$00		// store 0 in MSB of word value to display
        STA a76
        JSR sA1ED		// Display word value stored in ($75).w
        INC a83			// set message in window flag
        JMP b869E		// loop on keyboard read when in maze

//////////////////////////////////
// Reset message window and cursor
//////////////////////////////////
sA347   LDA #$05			// row number 5
        STA a4A
bA34B   LDA #$15			// column number 21
        STA a49
bA34F   LDA #$24			// load ' ' space char
        JSR s9E94			// Output char in AC
        LDA a49				// fill row until column 38 (included)
        CMP #$27
        BCC bA34F
        INC a4A				// next row
        LDA a4A
        CMP #$14			// repeat until row 19 (included)
        BNE bA34B			
        LDA #$06			// put cursor at row 6, column 22
        STA a4A
        LDA #$16
        STA a49
        RTS 

/////////////////////////////////////////////////
// Two line returns in message window and reset X
/////////////////////////////////////////////////
sA36B   INC a4A
////////////////////////////////////////////////
// One line return in message window and reset X
////////////////////////////////////////////////
sA36D   INC a4A
        LDA #$16
        STA a49
        LDX #$00
        RTS 

//////////////////////////////////
// Utility routine for stats bonus
// Compute A-$0F if A>$0F
// A==16 then X=1
// A==17 then X=2
// A==18 then X=3
// else X=0
//
// Return X value
///////////////////////////////////
sA376   LDX #$00
        CMP #$10
        BCC bA387
        INX 
        CMP #$11
        BCC bA387
        INX 
        CMP #$12
        BCC bA387
        INX 
bA387   RTS 

////////////////////////////////////////////////////////
// Write char from AC, and return to next line, column 9
////////////////////////////////////////////////////////
sA388   JSR s9E94		// Output char in AC
sA38B   LDA #$09		// return to next line, column 9
bA38D   STA a49
        INC a4A
        RTS 
		
////////////////////////////////
// Return to next line, column 5
////////////////////////////////
sA392   LDA #$05
        BNE bA38D
	
//////////////////
// DATA SECTION //	
//////////////////

// Attribute encoding :
// flipping bytes (and also attribute data offset) of all attribute code characters (21)
fA396   .BYTE $11,$19,$16,$12,$17,$10,$13,$10
        .BYTE $15,$18,$1C,$15,$11,$12,$1A,$16
        .BYTE $14,$13,$18,$1B,$17

// Does one code char encore the upper or lower 4 bits of character data ?
// If it encodes upper bytes, read CODE char, flip bytes and shift 4 bits left		
fA3AB   .BYTE $01,$00,$01,$01,$00,$01,$00,$00
        .BYTE $01,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$01,$01,$00,$01
		
// Table indexed with spell number, storing zero value for combat spells (first byte unused)
fA3C0   .BYTE $00,$00,$00,$01,$01,$00,$00,$01
        .BYTE $01,$00,$00,$01,$01,$00,$01,$01
        .BYTE $01,$00,$01

// Required spell points for each spell (first byte unused)
fA3D3   .BYTE $00,$01,$01,$01,$01,$02,$02,$02
        .BYTE $02,$03,$03,$03,$03,$04,$04,$05
        .BYTE $05,$06,$06
		
// Level thresholds for wandering monsters
// (deactivate monsters if (total party XP / 1024).b is > value
fA3E6   .BYTE $00,$05,$0B,$12,$1A

// Armor rating reduction for all shields (None, Shield, Magic shield, ...)
fA3EB   .BYTE $00,$01,$02,$03,$04

// Get armor rating of all armors (None, Leather armor, Chain mail, ...)
fA3F0   .BYTE $14,$11,$0E,$0B,$08

// Spell damage mask of combat spells and AR reduction of protection spells
fA3F5   .BYTE $00,$1F,$02,$00,$00,$0F,$04,$00
        .BYTE $00,$1F,$06,$00,$00,$00,$00,$00
        .BYTE $00,$3F
	
// Weapon damage mask for all weapon (None, Sword, Magic Sword, ...)
fA407   .BYTE $03,$07,$0F,$1F,$3F

// MSB of 1 unit in base 10 lookup table
// (1 in base 10 = $0001 in hex)
// (10 in base 10 = $000A in hex)
// (100 in base 10 = $0064 in hex)
// (1000 in base 10 = $03E8 in hex)
// (10000 in base 10 = $2710 in hex)
fA40C   .BYTE $00,$00,$00,$03,$27,$00,$00,$00

// LSB of 1 unit in base 10 lookup table
fA414   .BYTE $01,$0A,$64,$E8,$10,$00,$00,$00

// Values to store in bitmap to draw a pixel at 
// various X position inside a 8x8 block
fA41C   .BYTE $01,$02,$04,$08,$10,$20,$40,$80

// Text offset for direction 
// (NORTH = 0, EAST = 5, SOUTH = 10, WEST = 15 
fA424   .BYTE $00,$05,$0A,$0F

// Answer to the Balrog access enigma : "FATE"
fA428   .BYTE $0F,$0A,$1D,$0E

// Name offset of all items (relative to $BF00)
fA42C   .BYTE $00,$01,$07,$13,$1D,$28,$30,$3B
        .BYTE $47,$54,$5B,$68,$73,$7D,$8C,$9D
        .BYTE $AF
		
// LSB of message to display addresses when trigger fires
// (first and second are for upstairs, downstairs)
// (other messages alternate clue and hole for all levels)
fA43D   .BYTE $00,$36,$6C,$00,$B0,$00,$17,$00
        .BYTE $E1,$00,$72
		
// Monster name offset for ID 0..27
// Offset are relative to $A80D 
fA448   .BYTE $00,$08,$10,$18,$22,$2A,$35,$3C
        .BYTE $45,$4D,$57,$5F,$6A,$71,$76,$7E
        .BYTE $84,$8B,$96,$A3,$AE,$BB,$C8,$D4
        .BYTE $DB,$E4,$F2
		
// Monster name offset for ID 28..40
// Offset are relative to $A90B 		
fA463   .BYTE $00,$08,$13,$1D,$2A,$38,$43,$4B
        .BYTE $59,$64,$78,$85,$92
		
// Monster attack bonus
fA470   .BYTE $01,$01,$01,$01,$01,$01,$01,$01
        .BYTE $02,$02,$02,$02,$03,$03,$03,$04
        .BYTE $05,$04,$04,$05,$06,$07,$05,$06
        .BYTE $07,$08,$09,$08,$09,$0A,$0B,$0A
        .BYTE $0D,$0B,$0C,$0C,$0D,$0E,$0F,$1F
		
// Monster initial condition (HP)
fA498   .BYTE $08,$07,$09,$0D,$0B,$09,$0C,$0F
        .BYTE $10,$11,$10,$14,$11,$12,$13,$14
        .BYTE $16,$18,$19,$1B,$1C,$1E,$1D,$1F
        .BYTE $21,$24,$25,$27,$28,$2A,$2E,$32
        .BYTE $36,$38,$3A,$3E,$46,$5A,$6E,$FF

// Monster AR (ranging $0..$14) <-> (-10..+10)
fA4C0   .BYTE $14,$13,$12,$10,$12,$11,$11,$10
        .BYTE $11,$10,$0F,$0E,$0F,$0E,$0D,$0C
        .BYTE $09,$0B,$09,$0A,$08,$07,$06,$07
        .BYTE $06,$05,$05,$04,$05,$04,$06,$03
        .BYTE $01,$03,$01,$02,$01,$00,$00,$00

// MSB of bitmap address offset (relative to $20) of first 8x8 block at each screen row
fA4E8   .BYTE $00,$01,$02,$03,$05,$06,$07,$08
        .BYTE $0A,$0B,$0C,$0D,$0F,$10,$11,$12
        .BYTE $14,$15,$16,$17,$19,$1A,$1B,$1C
        .BYTE $1E,$1F,$20,$21,$23,$24,$25,$26
        .BYTE $28

// X/Y coordinates of wireframe vertices of 3D view
fA509   .BYTE $9F,$91,$78,$64,$5A	// X & Y
fA50E   .BYTE $00,$0F,$28,$3C,$46	// X & Y
fA513   .BYTE $0F,$28,$3C,$46,$4B	// X & Y
fA518   .BYTE $91,$78,$64,$5A,$55	// X & Y
fA51D   .BYTE $9F,$8C,$74,$61,$59	// X & Y
fA522   .BYTE $00,$14,$2C,$3F,$47	// X
fA527   .BYTE $0A,$1C,$32,$43,$49	// Y
fA52C   .BYTE $10,$2C,$3F,$48,$4C	// Y
fA531   .BYTE $06,$24,$39,$44,$4A	// X
fA536   .BYTE $9A,$7C,$67,$5C,$56	// X & Y
fA53B   .BYTE $1E,$32,$42,$4A,$4D	// X & Y
fA540   .BYTE $00,$1E,$36,$42,$49	// X
fA545   .BYTE $00,$28,$3C,$46,$4B	// Y
fA54A   .BYTE $00,$00,$14,$32,$41	// X
fA54F   .BYTE $00,$32,$42,$4A,$4D	// Y
fA554   .BYTE $00,$00,$1A,$36,$43	// X
fA559   .BYTE $9F,$82,$6A,$5E,$57	// X
fA55E   .BYTE $00,$9F,$8C,$6E,$5F	// X
fA563   .BYTE $00,$9F,$86,$6A,$5D	// X
fA568   .BYTE $82,$6E,$5E,$56,$53	// X

// Y start position of all 8 hurting star lines
fA56D   .BYTE $44,$52,$50,$50,$4A,$56,$4E,$52

// X start position of all 8 hurting star lines
fA575   .BYTE $50,$50,$44,$52,$4A,$4A,$52,$52

// Y end position of all 8 hurting star lines
fA57D   .BYTE $4E,$5C,$50,$50,$4E,$52,$4A,$56

// X end position of all 8 hurting star lines
fA585   .BYTE $50,$50,$4E,$5C,$4E,$4E,$56,$57

// "CHARACTER NAME   ARM CON CND CLASS"	
fA58D   .BYTE $0C,$11,$0A,$1B,$0A,$0C,$1D,$0E
        .BYTE $1B,$24,$17,$0A,$16,$0E,$24,$24
        .BYTE $24,$0A,$1B,$16,$24,$0C,$18,$17
        .BYTE $24,$0C,$17,$0D,$24,$0C,$15,$0A
        .BYTE $1C,$1C,$24
		
// "|   MAZE   |"
fA5B0   .BYTE $2B,$24,$30,$31,$32,$33,$34,$35
        .BYTE $36,$37,$38,$39,$3A,$3B,$24,$2B

// "|  MASTER  |"
fA5C0   .BYTE $2B,$24,$3C,$3D,$3E,$3F,$40,$41
        .BYTE $42,$43,$44,$45,$46,$47,$24,$2B

// "|BY MICHAEL CRANFORD |"
fA5D0   .BYTE $2B,$0B,$22,$24,$16,$12,$0C,$11
        .BYTE $0A,$0E,$15,$24,$0C,$1B,$0A,$17
        .BYTE $0F,$18,$1B,$0D,$24,$2B

// "CHARACTER NAME"
fA5E6   .BYTE $0C,$11,$0A,$1B,$0A,$0C,$1D,$0E
        .BYTE $1B,$24,$17,$0A,$16,$0E

// "| 1)"
// "| 2)"
// "| 3)"
fA5F4   .BYTE $2B,$24,$01,$28,$2B,$24,$02,$28
        .BYTE $2B,$24,$03,$28

// "| DO YOU WISH TO:"
fA600   .BYTE $2B,$24,$0D,$18,$24,$22,$18,$1E
        .BYTE $24,$20,$12,$1C,$11,$24,$1D,$18
        .BYTE $2A
		
// "| 1) ENTER A NEW CHARACTER   |"
// "| 2) BUY AN ITEM             |"
// "| 3) EXAMINE A CHARACTER     |"
// "| 4) DELETE A CHARACTER      |"
// "| 5) ENTER THE MAZE          |"
fA611   .BYTE $2B,$24,$01,$28,$24,$0E,$17,$1D
        .BYTE $0E,$1B,$24,$0A,$24,$17,$0E,$20
        .BYTE $24,$0C,$11,$0A,$1B,$0A,$0C,$1D
        .BYTE $0E,$1B,$24,$24,$24,$2B,$2B,$24
        .BYTE $02,$28,$24,$0B,$1E,$22,$24,$0A
        .BYTE $17,$24,$12,$1D,$0E,$16,$24,$24
        .BYTE $24,$24,$24,$24,$24,$24,$24,$24
        .BYTE $24,$24,$24,$2B,$2B,$24,$03,$28
        .BYTE $24,$0E,$21,$0A,$16,$12,$17,$0E
        .BYTE $24,$0A,$24,$0C,$11,$0A,$1B,$0A
        .BYTE $0C,$1D,$0E,$1B,$24,$24,$24,$24
        .BYTE $24,$2B,$2B,$24,$04,$28,$24,$0D
        .BYTE $0E,$15,$0E,$1D,$0E,$24,$0A,$24
        .BYTE $0C,$11,$0A,$1B,$0A,$0C,$1D,$0E
        .BYTE $1B,$24,$24,$24,$24,$24,$24,$2B
        .BYTE $2B,$24,$05,$28,$24,$0E,$17,$1D
        .BYTE $0E,$1B,$24,$1D,$11,$0E,$24,$16
        .BYTE $0A,$23,$0E,$24,$24,$24,$24,$24
        .BYTE $24,$24,$24,$24,$24,$2B
		
// "NAME: "
// "STRENGTH: "
// "INTELLECT: "
// "DEXTERITY: "
// "CONSTITUTION: "
// "GOLD: "
// "EXPERIENCE: "
// "WEAPON: "
// "SHIELD: "
// "ARMOR:  "
// "MISC.:  "
fA6A7   .BYTE $17,$0A,$16,$0E,$2A,$24,$1C,$1D
        .BYTE $1B,$0E,$17,$10,$1D,$11,$2A,$24
        .BYTE $FF,$12,$17,$1D,$0E,$15,$15,$0E
        .BYTE $0C,$1D,$2A,$24,$FF,$0D,$0E,$21
        .BYTE $1D,$0E,$1B,$12,$1D,$22,$2A,$24
        .BYTE $FF,$0C,$18,$17,$1C,$1D,$12,$1D
        .BYTE $1E,$1D,$12,$18,$17,$2A,$24,$FF
        .BYTE $10,$18,$15,$0D,$2A,$24,$FF,$0E
        .BYTE $21,$19,$0E,$1B,$12,$0E,$17,$0C
        .BYTE $0E,$2A,$24,$FF,$20,$0E,$0A,$19
        .BYTE $18,$17,$2A,$24,$FF,$1C,$11,$12
        .BYTE $0E,$15,$0D,$2A,$24,$FF,$0A,$1B
        .BYTE $16,$18,$1B,$2A,$24,$24,$FF,$16
        .BYTE $12,$1C,$0C,$26,$2A,$24,$24,$FF

// "CLASS (1-WAR  2-WIZ):"		
fA717   .BYTE $0C,$15,$0A,$1C,$1C,$24,$4A,$01
        .BYTE $49,$20,$0A,$1B,$24,$24,$02,$49
        .BYTE $20,$12,$23,$28,$2A

// "WARRIOR"
// "WIZARD"
fA72C   .BYTE $20,$0A,$1B,$1B,$12,$18,$1B,$20
        .BYTE $12,$23,$0A,$1B,$0D

// EXAMINE WHICH 1-3 (0-NONE)
fA739   .BYTE $0E,$21,$0A,$16,$12,$17,$0E,$24
        .BYTE $20,$11,$12,$0C,$11,$24,$01,$49
        .BYTE $03,$24,$4A,$00,$49,$17,$18,$17
        .BYTE $0E,$28

// "THE "
// "ITEMS:" 
// "HIT ANY KEY TO GO ON"
fA753   .BYTE $1D,$11,$0E,$24,$12,$1D,$0E,$16
        .BYTE $1C,$2A,$11,$12,$1D,$24,$0A,$17
        .BYTE $22,$24,$14,$0E,$22,$24,$1D,$18
        .BYTE $24,$10,$18,$24,$18,$17
		
// "SPELL PTS: "
fA771   .BYTE $1C,$19,$0E,$15,$15,$24,$19,$1D
        .BYTE $1C,$2A,$24
		
// "WHO WILL BUY? 1-3 (0:NONE)"
fA77C   .BYTE $20,$11,$18,$24,$20,$12,$15,$15
        .BYTE $24,$0B,$1E,$22,$27,$24,$01,$49
        .BYTE $03,$24,$4A,$00,$2A,$17,$18,$17
        .BYTE $0E,$28
		
// "TYPE (1-WE 2-AR 3-SH 4-MI)?"
fA796   .BYTE $1D,$22,$19,$0E,$24,$4A,$01,$49
        .BYTE $20,$0E,$24,$02,$49,$0A,$1B,$24
        .BYTE $03,$49,$1C,$11,$24,$04,$49,$16
        .BYTE $12,$28,$27

// "ITEM NUMBER? (1-4)"		
fA7B1   .BYTE $12,$1D,$0E,$16,$24,$17,$1E,$16
        .BYTE $0B,$0E,$1B,$27,$24,$4A,$01,$49
        .BYTE $04,$28

// "INSUFFICIENT FUNDS"		
fA7C3   .BYTE $12,$17,$1C,$1E,$0F,$0F,$12,$0C
        .BYTE $12,$0E,$17,$1D,$24,$0F,$1E,$17
        .BYTE $0D,$1C

// "WHO WILL CAST? 1-3 (0:NONE)"		
fA7D5   .BYTE $20,$11,$18,$24,$20,$12,$15,$15
        .BYTE $24,$0C,$0A,$1C,$1D,$27,$24,$01
        .BYTE $49,$03,$24,$4A,$00,$2A,$17,$18
        .BYTE $17,$0E,$28
		
// "FOR COMBAT ONLY"
// "LACK SPELL PTS"
fA7F0   .BYTE $0F,$18,$1B,$24,$0C,$18,$16,$0B
        .BYTE $0A,$1D,$24,$18,$17,$15,$22,$15
        .BYTE $0A,$0C,$14,$24,$1C,$19,$0E,$15
        .BYTE $15,$24,$19,$1D,$1C

// "THIEVES" "KOBOLDS" "GOBLINS" "SKELETONS"
// "DWARVES" "SCAVENGERS" "ROGUES" "WARRIORS"
// "PIRATES" "BLADESMEN" "ZOMBIES" "BERSERKERS"
// "WOLVES" "ORCS" "LURKERS" "OGRES"
// "TROLLS" "WEREWOLVES" "MAZE SHADOWS" "OGRE MAGI"
// "STONE GIANTS" "FIRE DRAGONS" "MERCENARIES" "WIGHTS"
// "SPECTRES" "GREEN DRAGONS" "FIRE GIANTS"
fA80D   .BYTE $1D,$11,$12,$0E,$1F,$0E,$1C,$FF
        .BYTE $14,$18,$0B,$18,$15,$0D,$1C,$FF
        .BYTE $10,$18,$0B,$15,$12,$17,$1C,$FF
        .BYTE $1C,$14,$0E,$15,$0E,$1D,$18,$17
        .BYTE $1C,$FF,$0D,$20,$0A,$1B,$1F,$0E
        .BYTE $1C,$FF,$1C,$0C,$0A,$1F,$0E,$17
        .BYTE $10,$0E,$1B,$1C,$FF,$1B,$18,$10
        .BYTE $1E,$0E,$1C,$FF,$20,$0A,$1B,$1B
        .BYTE $12,$18,$1B,$1C,$FF,$19,$12,$1B
        .BYTE $0A,$1D,$0E,$1C,$FF,$0B,$15,$0A
        .BYTE $0D,$0E,$1C,$16,$0E,$17,$FF,$23
        .BYTE $18,$16,$0B,$12,$0E,$1C,$FF,$0B
        .BYTE $0E,$1B,$1C,$0E,$1B,$14,$0E,$1B
        .BYTE $1C,$FF,$20,$18,$15,$1F,$0E,$1C
        .BYTE $FF,$18,$1B,$0C,$1C,$FF,$15,$1E
        .BYTE $1B,$14,$0E,$1B,$1C,$FF,$18,$10
        .BYTE $1B,$0E,$1C,$FF,$1D,$1B,$18,$15
        .BYTE $15,$1C,$FF,$20,$0E,$1B,$0E,$20
        .BYTE $18,$15,$1F,$0E,$1C,$FF,$16,$0A
        .BYTE $23,$0E,$24,$1C,$11,$0A,$0D,$18
        .BYTE $20,$1C,$FF,$18,$10,$1B,$0E,$24
        .BYTE $16,$0A,$10,$12,$FF,$FF,$1C,$1D
        .BYTE $18,$17,$0E,$24,$10,$12,$0A,$17
        .BYTE $1D,$1C,$FF,$0F,$12,$1B,$0E,$24
        .BYTE $0D,$1B,$0A,$10,$18,$17,$1C,$FF
        .BYTE $16,$0E,$1B,$0C,$0E,$17,$0A,$1B
        .BYTE $12,$0E,$1C,$FF,$20,$12,$10,$11
        .BYTE $1D,$1C,$FF,$1C,$19,$0E,$0C,$1D
        .BYTE $1B,$0E,$1C,$FF,$10,$1B,$0E,$0E
        .BYTE $17,$24,$0D,$1B,$0A,$10,$18,$17
        .BYTE $1C,$FF,$0F,$12,$1B,$0E,$24,$10
        .BYTE $12,$0A,$17,$1D,$1C,$FF
		
// "GORGONS" "OGRE KINGS" "MINOTAURS" "BLACK WOLVES"
// "BLACK DRAGONS" "ICE GIANTS" "SAMURAI" "SHADOW WOLVES"
// "MAZE OGRES" "BLACK TROLLS" "LICHES" "STORM GIANTS"
// "MAZE DRAGONS" "BALROG"
fA90B   .BYTE $10,$18,$1B,$10,$18,$17,$1C,$FF
        .BYTE $18,$10,$1B,$0E,$24,$14,$12,$17
        .BYTE $10,$1C,$FF,$16,$12,$17,$18,$1D
        .BYTE $0A,$1E,$1B,$1C,$FF,$0B,$15,$0A
        .BYTE $0C,$14,$24,$20,$18,$15,$1F,$0E
        .BYTE $1C,$FF,$0B,$15,$0A,$0C,$14,$24
        .BYTE $0D,$1B,$0A,$10,$18,$17,$1C,$FF
        .BYTE $12,$0C,$0E,$24,$10,$12,$0A,$17
        .BYTE $1D,$1C,$FF,$1C,$0A,$16,$1E,$1B
        .BYTE $0A,$12,$FF,$1C,$11,$0A,$0D,$18
        .BYTE $20,$24,$20,$18,$15,$1F,$0E,$1C
        .BYTE $FF,$16,$0A,$23,$0E,$24,$18,$10
        .BYTE $1B,$0E,$1C,$FF,$0B,$15,$0A,$0C
        .BYTE $14,$24,$1D,$1B,$18,$15,$15,$1C
        .BYTE $FF,$15,$12,$0C,$11,$0E,$1C,$FF
        .BYTE $1C,$1D,$18,$1B,$16,$24,$10,$12
        .BYTE $0A,$17,$1D,$1C,$FF,$16,$0A,$23
        .BYTE $0E,$24,$0D,$1B,$0A,$10,$18,$17
        .BYTE $1C,$FF,$0B,$0A,$15,$1B,$18,$10
        .BYTE $FF

// "MONSTERS ATTACK"		
fA9A4   .BYTE $16,$18,$17,$1C,$1D,$0E,$1B,$1C
        .BYTE $24,$0A,$1D,$1D,$0A,$0C,$14

// "RANDOMIZE? (Y-N)"		
fA9B3   .BYTE $1B,$0A,$17,$0D,$18,$16,$12,$23
        .BYTE $0E,$27,$24,$4A,$22,$49,$17,$28

// "COPYRIGHT (C) 1983 HES"		
fA9C3   .BYTE $0C,$18,$19,$22,$1B,$12,$10,$11
        .BYTE $1D,$24,$4A,$0C,$28,$24,$01,$09
        .BYTE $08,$03,$24,$11,$0E,$1C

// "CODE 1: "
// "CODE 2: "
// "CODE 3: "		
fA9D9   .BYTE $0C,$18,$0D,$0E,$24,$01,$2A,$24
        .BYTE $FF,$0C,$18,$0D,$0E,$24,$02,$2A
        .BYTE $24,$FF,$0C,$18,$0D,$0E,$24,$03
        .BYTE $2A,$24,$FF
		
// "CODE: "
// " HESS0" ???
fA9F4   .BYTE $0C,$18,$0D,$0E,$2A,$24
		.BYTE $24,$11,$0E,$1C,$1C,$00
		
// $AA00 (Level 0 walls ID)
		.BYTE $44,$04,$05,$05
        .BYTE $14,$44,$14,$44,$24,$A4,$95,$54
        .BYTE $48,$14,$66,$A5,$84,$14,$44,$14
        .BYTE $40,$11,$44,$14,$52,$42,$11,$42
        .BYTE $11,$41,$05,$21,$80,$20,$88,$14
        .BYTE $50,$50,$50,$50,$60,$A5,$81,$11
        .BYTE $49,$19,$45,$26,$84,$24,$84,$14
        .BYTE $43,$11,$41,$11,$50,$50,$50,$50
        .BYTE $42,$05,$05,$05,$25,$84,$14,$58
        .BYTE $41,$11,$41,$11,$4C,$24,$84,$34
        .BYTE $D0,$50,$50,$50,$48,$14,$44,$04
        .BYTE $16,$40,$10,$41,$05,$05,$06,$14
        .BYTE $41,$11,$41,$11,$51,$41,$11,$52
        .BYTE $42,$11,$42,$11,$59,$40,$00,$05
        .BYTE $14,$44,$18,$50,$44,$04,$14,$44
        .BYTE $24,$A5,$A5,$99,$49,$05,$0A,$05
        .BYTE $05,$00,$10,$65,$A0,$81,$11,$61
        .BYTE $81,$01,$11,$40,$20,$95,$44,$14
        .BYTE $44,$14,$48,$24,$96,$41,$00,$05
        .BYTE $01,$05,$05,$05,$05,$05,$25,$41
        .BYTE $21,$A5,$81,$12,$42,$21,$81,$11
        .BYTE $58,$54,$60,$84,$14,$65,$A5,$84
        .BYTE $04,$05,$05,$05,$05,$14,$44,$18
        .BYTE $48,$04,$24,$84,$10,$52,$50,$41
        .BYTE $11,$44,$14,$40,$10,$44,$14,$44
        .BYTE $24,$A0,$81,$11,$80,$00,$10,$41
        .BYTE $11,$69,$90,$44,$14,$41,$12,$40
        .BYTE $10,$42,$11,$41,$11,$40,$05,$24
        .BYTE $41,$01,$10,$44,$24,$85,$20,$81
        .BYTE $11,$44,$08,$01,$01,$08,$14,$44
        .BYTE $14,$50,$56,$50,$44,$14,$50,$41
        .BYTE $11,$56,$51,$44,$24,$80,$10,$44
        .BYTE $14,$40,$20,$81,$11,$40,$0A,$10
        .BYTE $42,$11,$60,$84,$14,$48,$14,$41
        .BYTE $11,$40,$10,$41,$12,$40,$20,$84
        .BYTE $14,$50,$5A,$50,$48,$04,$10,$42
        .BYTE $22,$80,$20,$84,$24,$80,$00,$04
        .BYTE $08,$00,$10,$41,$11,$40,$0A,$10
        .BYTE $41,$01,$12,$59,$59,$41,$11,$41
        .BYTE $11,$40,$01,$02,$02,$02,$12,$44
        .BYTE $14,$50,$59,$50,$44,$04,$18,$44
        .BYTE $24,$84,$24,$84,$14,$41,$14,$59
        .BYTE $59,$59,$59,$41,$21,$81,$05,$11
        .BYTE $81,$02,$11,$41,$12,$41,$11,$41
        .BYTE $12,$44,$10,$44,$05,$05,$06,$05
        .BYTE $05,$06,$06,$25,$44,$18,$56,$45
        .BYTE $18,$44,$14,$44,$08,$11,$41,$10
        .BYTE $4C,$14,$48,$14,$44,$18,$48,$14
        .BYTE $41,$11,$69,$A5,$81,$11,$41,$11
        .BYTE $41,$05,$05,$11,$42,$11,$41,$11
        .BYTE $41,$11,$41,$11
		
// $AB90 (triggers Lvl 0)
		.BYTE $00,$00,$0C,$06
        .BYTE $03,$05,$FF,$FF,$05,$02,$08,$01
        .BYTE $01,$0E,$0D,$00,$0E,$08,$0F,$12
        .BYTE $05,$11,$0D,$03,$03,$0F,$0C,$05
        .BYTE $0D,$0F,$02,$0A,$04,$0A,$06,$07
        .BYTE $09,$05,$10,$0B,$0B,$04,$06,$09
        .BYTE $0B,$12,$0B,$07,$0D,$12,$06,$0C
        .BYTE $10,$0D,$07,$11,$12,$0C,$10,$05
        .BYTE $12,$02,$09,$10,$07,$02,$08,$07
        .BYTE $07,$04,$08,$09,$06,$11,$12,$0E
        .BYTE $0F,$03,$10,$0C,$12,$01,$0F,$04
        .BYTE $00,$0A,$10,$0E,$0D,$0C,$0C,$0F
        .BYTE $FF,$FF,$FF,$FF,$10,$02,$0A,$10
        .BYTE $12,$12,$05,$12,$02,$02,$01,$05
        .BYTE $04,$00,$05,$04

// $AC00 (Lvl 1 walls ID)		
		.BYTE $50,$49,$16,$44
        .BYTE $14,$50,$49,$16,$44,$14,$50,$49
        .BYTE $16,$44,$14,$50,$49,$16,$44,$14
        .BYTE $50,$44,$28,$82,$11,$50,$44,$28
        .BYTE $82,$11,$50,$44,$28,$82,$11,$50
        .BYTE $44,$28,$82,$11,$50,$41,$11,$49
        .BYTE $16,$50,$41,$12,$49,$15,$50,$41
        .BYTE $11,$49,$16,$50,$41,$11,$49,$16
        .BYTE $00,$06,$05,$05,$09,$00,$06,$09
        .BYTE $05,$05,$00,$06,$05,$05,$09,$00
        .BYTE $06,$05,$05,$09,$50,$49,$16,$44
        .BYTE $14,$50,$49,$16,$44,$14,$50,$49
        .BYTE $16,$44,$14,$50,$49,$16,$44,$14
        .BYTE $50,$44,$28,$82,$11,$50,$44,$28
        .BYTE $82,$11,$50,$44,$28,$82,$11,$50
        .BYTE $44,$28,$82,$11,$50,$41,$11,$49
        .BYTE $16,$50,$41,$11,$49,$16,$50,$41
        .BYTE $11,$49,$16,$50,$41,$11,$49,$16
        .BYTE $00,$06,$05,$05,$09,$00,$05,$05
        .BYTE $05,$09,$00,$06,$05,$05,$09,$00
        .BYTE $06,$05,$05,$09,$50,$49,$16,$44
        .BYTE $14,$50,$44,$05,$14,$54,$50,$49
        .BYTE $16,$44,$14,$50,$49,$16,$44,$14
        .BYTE $50,$44,$28,$82,$11,$50,$50,$54
        .BYTE $50,$50,$50,$44,$28,$82,$11,$50
        .BYTE $44,$28,$82,$11,$50,$41,$11,$49
        .BYTE $16,$50,$41,$11,$50,$50,$52,$41
        .BYTE $11,$49,$16,$50,$41,$11,$49,$16
        .BYTE $00,$06,$05,$05,$09,$00,$06,$15
        .BYTE $50,$40,$09,$05,$15,$45,$09,$00
        .BYTE $06,$05,$05,$09,$50,$49,$16,$44
        .BYTE $14,$50,$49,$16,$50,$50,$46,$14
        .BYTE $56,$44,$14,$50,$49,$16,$44,$14
        .BYTE $50,$44,$28,$82,$11,$50,$44,$38
        .BYTE $D0,$50,$59,$41,$29,$81,$12,$50
        .BYTE $44,$28,$82,$11,$50,$41,$11,$49
        .BYTE $16,$50,$41,$11,$51,$41,$05,$05
        .BYTE $05,$05,$19,$50,$41,$11,$49,$16
        .BYTE $00,$06,$05,$05,$09,$00,$06,$05
        .BYTE $05,$05,$04,$06,$05,$05,$05,$00
        .BYTE $06,$05,$05,$09,$50,$49,$16,$44
        .BYTE $14,$50,$49,$16,$44,$14,$50,$49
        .BYTE $16,$44,$14,$50,$49,$16,$44,$14
        .BYTE $50,$44,$28,$82,$11,$50,$44,$28
        .BYTE $82,$11,$50,$44,$28,$82,$11,$50
        .BYTE $44,$28,$82,$11,$50,$41,$11,$49
        .BYTE $16,$50,$41,$11,$49,$16,$50,$41
        .BYTE $11,$49,$16,$50,$41,$11,$49,$16
        .BYTE $00,$06,$05,$05,$09,$00,$06,$05
        .BYTE $05,$09,$00,$06,$05,$05,$09,$00
        .BYTE $06,$05,$05,$09
		
// $AD90 (triggers Lvl 1)
		.BYTE $0C,$06,$09,$07
        .BYTE $0D,$0A,$FF,$FF,$01,$07,$05,$03
        .BYTE $01,$02,$05,$0C,$05,$07,$11,$11
        .BYTE $11,$12,$01,$03,$01,$08,$11,$0C
        .BYTE $01,$12,$0C,$0C,$0D,$0E,$09,$03
        .BYTE $08,$0C,$11,$03,$08,$09,$01,$0D
        .BYTE $05,$0D,$08,$11,$09,$02,$0C,$10
        .BYTE $06,$08,$05,$11,$0D,$02,$0D,$12
        .BYTE $09,$12,$05,$12,$0A,$13,$09,$0D
        .BYTE $0D,$03,$09,$11,$05,$02,$09,$0C
        .BYTE $00,$07,$11,$08,$11,$02,$0A,$0D
        .BYTE $08,$02,$01,$0C,$12,$09,$01,$11
        .BYTE $11,$0D,$FF,$FF,$10,$06,$04,$11
        .BYTE $0D,$07,$10,$0C,$0A,$04,$05,$08
        .BYTE $00,$0B,$11,$07
		
// $AE00 (Lvl 2 walls ID)	
		.BYTE $44,$24,$85,$24
        .BYTE $95,$44,$24,$95,$40,$05,$10,$44
        .BYTE $14,$44,$14,$44,$14,$44,$14,$56
        .BYTE $40,$10,$56,$41,$04,$01,$00,$14
        .BYTE $50,$65,$D0,$41,$12,$41,$12,$41
        .BYTE $12,$41,$22,$99,$41,$11,$68,$95
        .BYTE $51,$54,$40,$11,$41,$04,$11,$45
        .BYTE $09,$05,$09,$07,$29,$85,$08,$24
        .BYTE $44,$24,$80,$25,$96,$60,$90,$44
        .BYTE $14,$52,$44,$05,$05,$04,$04,$2C
        .BYTE $84,$14,$42,$11,$41,$11,$50,$45
        .BYTE $09,$11,$50,$42,$11,$49,$12,$44
        .BYTE $24,$80,$02,$10,$41,$11,$48,$14
        .BYTE $44,$14,$40,$04,$05,$05,$10,$58
        .BYTE $44,$14,$58,$41,$11,$50,$59,$50
        .BYTE $44,$14,$41,$11,$81,$21,$81,$10
        .BYTE $44,$24,$90,$50,$42,$11,$50,$45
        .BYTE $05,$00,$04,$20,$81,$11,$44,$25
        .BYTE $66,$96,$66,$90,$41,$11,$50,$50
        .BYTE $58,$64,$90,$44,$14,$40,$01,$20
        .BYTE $84,$14,$60,$95,$5A,$5A,$5A,$50
        .BYTE $44,$14,$50,$50,$41,$11,$60,$80
        .BYTE $20,$90,$64,$90,$41,$11,$41,$14
        .BYTE $5A,$5A,$5A,$50,$41,$21,$90,$40
        .BYTE $05,$05,$10,$41,$11,$60,$91,$40
        .BYTE $04,$14,$65,$90,$5A,$69,$99,$50
        .BYTE $44,$24,$90,$50,$44,$24,$90,$64
        .BYTE $85,$01,$05,$01,$01,$10,$44,$11
        .BYTE $69,$95,$44,$11,$41,$11,$50,$50
        .BYTE $41,$11,$50,$50,$44,$14,$56,$44
        .BYTE $14,$50,$60,$95,$44,$18,$50,$44
        .BYTE $14,$65,$A0,$81,$04,$04,$11,$61
        .BYTE $81,$11,$49,$01,$12,$50,$41,$16
        .BYTE $41,$21,$A0,$81,$21,$95,$50,$65
        .BYTE $81,$21,$A5,$A5,$86,$05,$06,$15
        .BYTE $48,$10,$44,$18,$45,$06,$01,$06
        .BYTE $05,$05,$01,$04,$16,$56,$46,$04
        .BYTE $18,$44,$0A,$25,$82,$11,$41,$12
        .BYTE $44,$18,$44,$18,$44,$04,$16,$50
        .BYTE $48,$0C,$18,$41,$11,$50,$48,$14
        .BYTE $49,$06,$05,$18,$41,$11,$41,$11
        .BYTE $42,$11,$59,$50,$41,$00,$11,$44
        .BYTE $14,$50,$42,$21,$85,$19,$54,$50
        .BYTE $44,$06,$05,$06,$09,$06,$05,$10
        .BYTE $54,$52,$54,$42,$11,$50,$49,$14
        .BYTE $44,$05,$11,$50,$50,$59,$56,$59
        .BYTE $56,$59,$56,$50,$40,$09,$10,$48
        .BYTE $14,$50,$65,$91,$50,$44,$14,$50
        .BYTE $41,$05,$09,$05,$09,$05,$09,$11
        .BYTE $70,$95,$50,$41,$21,$81,$25,$95
        .BYTE $41,$11,$41,$11,
	
// $AF90 (triggers Lvl 2)	
		.BYTE $09,$07,$02,$04
        .BYTE $09,$09,$10,$12,$09,$01,$01,$0C
        .BYTE $08,$00,$04,$0C,$00,$04,$10,$0F
        .BYTE $00,$01,$03,$01,$13,$0C,$0D,$05
        .BYTE $01,$02,$03,$04,$06,$10,$06,$05
        .BYTE $04,$10,$10,$11,$0A,$09,$05,$0E
        .BYTE $12,$01,$07,$13,$01,$0E,$09,$12
        .BYTE $0A,$05,$04,$12,$01,$10,$01,$09
        .BYTE $13,$09,$0D,$09,$08,$11,$08,$02
        .BYTE $0D,$10,$08,$10,$04,$07,$0E,$0A
        .BYTE $0C,$0C,$12,$03,$12,$04,$0C,$10
        .BYTE $12,$0E,$01,$12,$0E,$13,$10,$06
        .BYTE $00,$13,$0A,$00,$0D,$07,$0D,$11
        .BYTE $09,$0E,$09,$02,$07,$02,$07,$09
        .BYTE $06,$08,$0C,$05
		
// $B000 (Lvl 3 walls ID)	
		.BYTE $44,$05,$05,$05
        .BYTE $14,$44,$14,$44,$04,$04,$04,$04
        .BYTE $04,$14,$44,$14,$44,$14,$44,$14
        .BYTE $50,$56,$64,$95,$53,$41,$12,$40
        .BYTE $00,$02,$00,$00,$02,$10,$41,$12
        .BYTE $50,$50,$50,$50,$50,$5A,$52,$45
        .BYTE $0C,$15,$58,$40,$10,$59,$40,$10
        .BYTE $59,$40,$14,$58,$50,$50,$50,$50
        .BYTE $50,$5A,$69,$A5,$A0,$85,$11,$40
        .BYTE $00,$04,$00,$00,$04,$00,$10,$50
        .BYTE $50,$50,$50,$50,$50,$69,$A5,$A5
        .BYTE $A0,$95,$56,$40,$00,$01,$01,$01
        .BYTE $00,$01,$10,$50,$50,$50,$50,$50
        .BYTE $50,$44,$24,$A5,$A0,$A5,$99,$41
        .BYTE $21,$84,$04,$14,$60,$95,$50,$50
        .BYTE $50,$50,$50,$50,$50,$42,$21,$A5
        .BYTE $A0,$85,$14,$44,$14,$41,$02,$11
        .BYTE $41,$04,$10,$50,$50,$50,$50,$50
        .BYTE $50,$59,$44,$24,$A2,$85,$12,$41
        .BYTE $21,$85,$08,$25,$94,$40,$10,$41
        .BYTE $11,$50,$50,$50,$50,$65,$81,$11
        .BYTE $69,$95,$59,$56,$54,$56,$50,$46
        .BYTE $11,$40,$10,$44,$14,$50,$50,$50
        .BYTE $50,$44,$24,$85,$45,$14,$44,$18
        .BYTE $40,$1A,$50,$48,$14,$40,$11,$41
        .BYTE $12,$41,$11,$50,$50,$41,$12,$64
        .BYTE $95,$50,$42,$21,$91,$59,$50,$42
        .BYTE $11,$52,$44,$05,$09,$14,$45,$11
        .BYTE $40,$04,$08,$10,$45,$21,$88,$25
        .BYTE $84,$14,$50,$48,$04,$19,$50,$44
        .BYTE $14,$50,$48,$14,$40,$00,$00,$00
        .BYTE $04,$14,$50,$54,$41,$11,$50,$41
        .BYTE $11,$64,$90,$41,$12,$50,$41,$12
        .BYTE $40,$00,$00,$01,$00,$10,$50,$41
        .BYTE $05,$05,$01,$05,$05,$11,$60,$95
        .BYTE $48,$10,$44,$18,$40,$00,$10,$65
        .BYTE $C0,$10,$41,$14,$44,$14,$44,$14
        .BYTE $44,$04,$22,$95,$42,$11,$41,$12
        .BYTE $40,$01,$00,$04,$00,$00,$14,$50
        .BYTE $50,$50,$50,$50,$50,$50,$48,$14
        .BYTE $49,$06,$05,$18,$51,$56,$41,$00
        .BYTE $00,$00,$10,$41,$11,$41,$11,$41
        .BYTE $11,$50,$41,$21,$85,$19,$54,$50
        .BYTE $44,$09,$14,$41,$01,$01,$01,$05
        .BYTE $05,$05,$05,$05,$05,$22,$84,$14
        .BYTE $44,$05,$11,$50,$41,$14,$50,$44
        .BYTE $04,$04,$04,$06,$04,$04,$04,$24
        .BYTE $84,$18,$41,$10,$50,$44,$14,$50
        .BYTE $45,$11,$61,$C1,$01,$01,$11,$59
        .BYTE $41,$01,$01,$11,$41,$11,$65,$91
        .BYTE $41,$11,$41,$11
		
// $B190 (triggers lvl 3)
		.BYTE $02,$04,$13,$00
        .BYTE $0E,$03,$FF,$FF,$08,$01,$07,$03
        .BYTE $07,$01,$01,$04,$06,$03,$05,$05
        .BYTE $07,$05,$06,$05,$13,$07,$01,$01
        .BYTE $09,$02,$02,$09,$08,$05,$03,$01
        .BYTE $04,$05,$0E,$10,$03,$02,$04,$06
        .BYTE $0E,$0F,$07,$08,$0A,$04,$0C,$10
        .BYTE $0C,$13,$12,$0D,$13,$0E,$0A,$0B
        .BYTE $02,$0C,$10,$01,$10,$11,$03,$05
        .BYTE $04,$02,$04,$03,$13,$02,$0A,$09
        .BYTE $04,$0A,$0A,$08,$12,$0B,$0B,$04
        .BYTE $05,$03,$08,$07,$01,$0F,$09,$10
        .BYTE $0B,$08,$01,$06,$06,$0A,$0E,$13
        .BYTE $0D,$0F,$05,$0D,$03,$03,$08,$06
        .BYTE $01,$03,$08,$09

// $B200 (Lvl 4 walls ID)			
		.BYTE $44,$05,$05,$04
        .BYTE $24,$A5,$A5,$84,$24,$80,$00,$14
        .BYTE $45,$04,$14,$65,$84,$05,$24,$95
        .BYTE $50,$44,$14,$40,$20,$84,$14,$41
        .BYTE $11,$41,$01,$10,$44,$10,$40,$15
        .BYTE $40,$14,$41,$14,$50,$40,$11,$41
        .BYTE $11,$41,$21,$A5,$A5,$84,$24,$A1
        .BYTE $91,$41,$01,$05,$11,$51,$44,$11
        .BYTE $52,$52,$66,$84,$04,$04,$04,$04
        .BYTE $14,$40,$10,$44,$04,$04,$04,$04
        .BYTE $14,$84,$20,$96,$48,$08,$18,$40
        .BYTE $00,$01,$01,$00,$10,$41,$11,$40
        .BYTE $00,$01,$01,$00,$10,$41,$11,$5A
        .BYTE $41,$01,$12,$40,$10,$44,$14,$40
        .BYTE $00,$04,$04,$00,$20,$95,$65,$80
        .BYTE $10,$64,$84,$18,$56,$44,$18,$40
        .BYTE $10,$41,$21,$80,$01,$01,$01,$01
        .BYTE $20,$95,$65,$80,$10,$52,$41,$11
        .BYTE $4A,$01,$12,$40,$00,$04,$04,$10
        .BYTE $44,$05,$05,$15,$40,$04,$04,$00
        .BYTE $10,$48,$24,$95,$69,$96,$58,$41
        .BYTE $01,$00,$00,$10,$50,$44,$04,$04
        .BYTE $00,$00,$00,$01,$11,$42,$21,$95
        .BYTE $04,$18,$41,$05,$14,$40,$00,$10
        .BYTE $50,$41,$01,$00,$00,$00,$10,$44
        .BYTE $05,$19,$44,$04,$01,$11,$44,$05
        .BYTE $11,$40,$00,$10,$40,$05,$25,$80
        .BYTE $00,$00,$10,$41,$05,$24,$81,$01
        .BYTE $44,$14,$50,$44,$04,$00,$00,$10
        .BYTE $50,$45,$05,$01,$00,$00,$00,$04
        .BYTE $14,$40,$24,$95,$41,$12,$50,$40
        .BYTE $00,$01,$02,$10,$41,$05,$05,$15
        .BYTE $40,$02,$01,$00,$10,$41,$01,$14
        .BYTE $44,$28,$90,$40,$10,$54,$58,$40
        .BYTE $04,$04,$04,$04,$10,$4A,$15,$40
        .BYTE $10,$44,$14,$50,$41,$11,$50,$40
        .BYTE $10,$52,$51,$40,$00,$01,$01,$00
        .BYTE $10,$79,$95,$40,$10,$41,$21,$90
        .BYTE $44,$05,$11,$40,$00,$08,$04,$00
        .BYTE $10,$44,$16,$40,$00,$04,$04,$00
        .BYTE $10,$44,$05,$11,$50,$44,$24,$41
        .BYTE $01,$01,$01,$01,$11,$52,$59,$41
        .BYTE $01,$01,$01,$01,$21,$A2,$84,$14
        .BYTE $61,$82,$00,$25,$A5,$84,$24,$85
        .BYTE $05,$08,$04,$05,$14,$44,$14,$64
        .BYTE $94,$59,$41,$12,$44,$18,$51,$44
        .BYTE $14,$42,$22,$84,$14,$40,$10,$65
        .BYTE $90,$42,$11,$50,$50,$44,$14,$58
        .BYTE $41,$31,$A5,$41,$11,$59,$59,$41
        .BYTE $11,$40,$10,$65,$81,$09,$05,$11
        .BYTE $61,$81,$21,$91
		
// $B390 (triggers Lvl 4)
		.BYTE $13,$00,$FF,$FF
        .BYTE $13,$02,$FF,$FF,$00,$06,$0E,$05
        .BYTE $0E,$12,$00,$05,$06,$00,$11,$11
        .BYTE $01,$05,$07,$0B,$00,$08,$12,$13
        .BYTE $0A,$0A,$13,$03,$0D,$01,$13,$05
        .BYTE $0C,$01,$10,$09,$06,$0E,$0E,$0D
        .BYTE $04,$13,$08,$00,$08,$13,$00,$13
        .BYTE $03,$13,$13,$0B,$0C,$0B,$07,$13
        .BYTE $06,$06,$FF,$FF,$11,$04,$03,$01
        .BYTE $05,$12,$02,$07,$0D,$0D,$02,$0A
        .BYTE $00,$0C,$0B,$13,$00,$15,$12,$0E
        .BYTE $0D,$06,$01,$0F,$12,$0D,$0E,$0E
        .BYTE $10,$0A,$FF,$FF,$06,$0D,$05,$0D
        .BYTE $08,$01,$05,$0E,$03,$02,$11,$00
        .BYTE $13,$06,$12,$07
	
// $B400 'Skeleton' sprite upper-left
		.BYTE $00,$00,$00,$00
        .BYTE $00,$02,$00,$00,$0A,$00,$00,$09
        .BYTE $00,$00,$0A,$00,$00,$0A,$08,$00
        .BYTE $02,$28,$00,$00,$28,$80,$02,$0A
        .BYTE $00,$00,$08,$02,$AA,$08,$08,$80
        .BYTE $08,$08,$0A,$08,$28,$20,$08,$20
        .BYTE $88,$08,$A0,$80,$08,$80,$20,$0A
        .BYTE $80,$08,$02,$00,$00,$00,$00,$02
        .BYTE $00,$00,$0A,$00
	
// $B440 'Skeleton' sprite upper-right	
		.BYTE $$00,$00,$00,$A0
        .BYTE $00,$00,$A8,$00,$00,$98,$00,$00
        .BYTE $A8,$02,$80,$68,$00,$80,$A0,$00
        .BYTE $80,$00,$02,$80,$A0,$00,$A0,$80
        .BYTE $00,$20,$AA,$A0,$20,$80,$80,$28
        .BYTE $A8,$28,$08,$82,$0A,$08,$88,$82
        .BYTE $88,$80,$80,$A8,$82,$00,$20,$88
        .BYTE $00,$00,$80,$00,$00,$A0,$00,$00
        .BYTE $A8,$00,$00,$00
		
// "CONGRATULATIONS,BUT THE BATTLE  GOES ON. SEEK   HIS ALLIES IN   ADVENTURE 2:    SHADOW SNARE    "
fB480   .BYTE $0C,$18,$17,$10,$1B,$0A,$1D,$1E
        .BYTE $15,$0A,$1D,$12,$18,$17,$1C,$25
        .BYTE $0B,$1E,$1D,$24,$1D,$11,$0E,$24
        .BYTE $0B,$0A,$1D,$1D,$15,$0E,$24,$24
        .BYTE $10,$18,$0E,$1C,$24,$18,$17,$26
        .BYTE $24,$1C,$0E,$0E,$14,$24,$24,$24
        .BYTE $11,$12,$1C,$24,$0A,$15,$15,$12
        .BYTE $0E,$1C,$24,$12,$17,$24,$24,$24
        .BYTE $0A,$0D,$1F,$0E,$17,$1D,$1E,$1B
        .BYTE $0E,$24,$02,$2A,$24,$24,$24,$24
        .BYTE $1C,$11,$0A,$0D,$18,$20,$24,$1C
        .BYTE $17,$0A,$1B,$0E,$24,$24,$24,$24
        .BYTE $00

// MSB of message to display addresses when trigger fires
// (first and second are for upstairs, downstairs)
// (other messages alternate clue and hole for all levels)
fB4E1   .BYTE $BA,$BA,$BA,$00,$BA,$00,$BB,$00
        .BYTE $BA,$00,$BB

// MSB of square offset for an YPos in level AND a given level
fB4EC   .BYTE $AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
        .BYTE $AA,$AA,$AA,$AA,$AA,$AB,$AB,$AB
        .BYTE $AB,$AB,$AB,$AB
		
// $B500 'Knight' sprite upper-left
		.BYTE $00,$00,$00,$00
        .BYTE $00,$02,$00,$00,$0A,$04,$00,$0B
        .BYTE $05,$00,$0A,$05,$40,$0A,$05,$50
        .BYTE $0A,$05,$54,$03,$05,$95,$FF,$06
        .BYTE $95,$FF,$05,$95,$FF,$05,$A5,$FF
        .BYTE $05,$95,$BF,$05,$95,$AA,$05,$95
        .BYTE $AA,$05,$95,$AA,$01,$55,$AA,$01
        .BYTE $54,$2A,$00,$50,$2A,$00,$40,$2A
        .BYTE $00,$00,$2A,$00
		
// $B540 'Knight' sprite upper-right
		.BYTE $02,$00,$00,$A2
        .BYTE $80,$00,$A8,$A0,$00,$F8,$28,$00
        .BYTE $E8,$0A,$00,$E8,$02,$81,$E8,$00
        .BYTE $A4,$F0,$00,$1A,$FF,$F0,$6A,$FF
        .BYTE $FC,$0F,$FF,$FC,$0F,$FF,$FC,$0F
        .BYTE $FF,$BF,$3F,$AA,$BF,$3F,$AA,$BF
        .BYTE $FC,$AA,$8F,$FC,$AA,$80,$F0,$AA
        .BYTE $00,$00,$AA,$00,$00,$AA,$00,$00
        .BYTE $AA,$00,$00,$00
		
// $B580 'Humanoid legs' sprite lower-left
		.BYTE $00,$00,$15,$00
        .BYTE $00,$55,$00,$00,$55,$00,$01,$55
        .BYTE $00,$01,$54,$00,$05,$50,$00,$05
        .BYTE $40,$00,$05,$40,$00,$15,$40,$00
        .BYTE $15,$00,$00,$15,$40,$00,$05,$40
        .BYTE $00,$05,$50,$00,$01,$50,$00,$01
        .BYTE $50,$00,$00,$7C,$00,$00,$FF,$00
        .BYTE $00,$3F,$00,$00,$3C,$00,$00,$3C
        .BYTE $00,$00,$FC,$00
		
// $B5C0 'Humanoid legs' sprite lower-right
		.BYTE $55,$00,$00,$55
        .BYTE $00,$00,$55,$00,$00,$15,$00,$00
        .BYTE $15,$00,$00,$15,$00,$00,$15,$00
        .BYTE $00,$15,$40,$00,$05,$40,$00,$05
        .BYTE $40,$00,$05,$40,$00,$05,$40,$00
        .BYTE $05,$40,$00,$05,$40,$00,$0F,$C0
        .BYTE $00,$03,$C0,$00,$03,$C0,$00,$03
        .BYTE $C0,$00,$03,$C0,$00,$03,$F0,$00
        .BYTE $03,$FF,$00,$00
	
// $B600 'Kobold' sprite upper-left
		.BYTE $00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$01,$00,$00
        .BYTE $06,$28,$00,$0B,$28,$00,$0A,$2A
        .BYTE $00,$02,$14,$00,$02,$14,$00,$01
        .BYTE $14,$01,$55,$14,$05,$D5,$15,$05
        .BYTE $F5,$05,$15,$FF,$05,$55,$FF,$05
        .BYTE $54,$FD,$01,$50,$35,$00,$00,$35
        .BYTE $00,$00,$35,$00
		
// $B640 'Kobold' sprite upper-right
		.BYTE $00,$00,$00,$00
        .BYTE $00,$00,$00,$50,$00,$01,$54,$00
        .BYTE $01,$54,$00,$50,$5F,$00,$64,$03
        .BYTE $C0,$B8,$00,$F8,$A8,$00,$3A,$E0
        .BYTE $00,$2A,$A0,$00,$05,$50,$00,$05
        .BYTE $55,$50,$05,$55,$D5,$05,$57,$D5
        .BYTE $45,$FF,$C5,$55,$FF,$C1,$55,$5F
        .BYTE $C0,$54,$57,$00,$00,$57,$00,$00
        .BYTE $57,$00,$00,$00
		
// $B680 'Giant' sprite upper-left
		.BYTE $00,$00,$00,$00
        .BYTE $00,$03,$00,$00,$01,$00,$F0,$02
        .BYTE $03,$FC,$02,$03,$FF,$02,$03,$FF
        .BYTE $01,$00,$FF,$55,$00,$3F,$D5,$00
        .BYTE $3F,$D5,$00,$2F,$D5,$00,$AB,$F5
        .BYTE $02,$A3,$F5,$02,$80,$F5,$02,$80
        .BYTE $39,$02,$80,$2A,$02,$80,$2A,$02
        .BYTE $80,$1F,$03,$C0,$17,$02,$A0,$15
        .BYTE $02,$80,$15,$00
	
// $B6C0 'Giant' sprite upper-right	
		.BYTE $00,$00,$00,$F0
        .BYTE $00,$00,$90,$00,$00,$A0,$00,$00
        .BYTE $A0,$00,$00,$A0,$00,$00,$50,$00
        .BYTE $00,$55,$54,$00,$55,$5A,$00,$55
        .BYTE $5A,$00,$55,$5A,$00,$55,$5A,$00
        .BYTE $55,$5A,$00,$55,$6A,$00,$55,$A8
        .BYTE $00,$AA,$A8,$00,$AA,$A0,$00,$55
        .BYTE $00,$00,$55,$00,$00,$55,$00,$00
        .BYTE $55,$00,$00,$00
	
// $B700 'Lurker' sprite upper-left
		.BYTE $00,$00,$00,$00
        .BYTE $00,$33,$00,$00,$0F,$00,$00,$0D
        .BYTE $00,$00,$0F,$00,$3C,$0F,$00,$F0
        .BYTE $01,$00,$FC,$03,$00,$C0,$02,$03
        .BYTE $C2,$AA,$03,$0F,$AA,$0F,$3F,$EB
        .BYTE $0F,$FF,$FB,$3F,$FC,$FF,$3F,$C0
        .BYTE $FF,$3C,$00,$FF,$00,$00,$3F,$00
        .BYTE $00,$3F,$00,$00,$3F,$00,$00,$3F
        .BYTE $00,$00,$3F,$00
		
// $B740 'Lurker' sprite upper-right
		.BYTE $00,$00,$00,$F3
        .BYTE $00,$00,$FC,$00,$30,$DC,$00,$3C
        .BYTE $FC,$00,$3C,$BC,$00,$FC,$50,$00
        .BYTE $3C,$F0,$00,$3C,$A0,$00,$3C,$AA
        .BYTE $A0,$3C,$AA,$BC,$3C,$BA,$FF,$3C
        .BYTE $BB,$FF,$3C,$BF,$FF,$FC,$FF,$CF
        .BYTE $FC,$FF,$C3,$F0,$FF,$00,$00,$FF
        .BYTE $00,$00,$FF,$00,$00,$FF,$00,$00
        .BYTE $FF,$00,$00,$00
		
// "GLANCES HIS FOE"
// "SLASHES HIS FOE"
// "STRIKES MIGHTILY"
fB780   .BYTE $10,$15,$0A,$17,$0C,$0E,$1C,$24
        .BYTE $11,$12,$1C,$24,$0F,$18,$0E,$FF
        .BYTE $1C,$15,$0A,$1C,$11,$0E,$1C,$24
        .BYTE $11,$12,$1C,$24,$0F,$18,$0E,$FF
        .BYTE $1C,$1D,$1B,$12,$14,$0E,$1C,$24
        .BYTE $16,$12,$10,$11,$1D,$12,$15,$22
        .BYTE $FF
		
// "DODGES THE BLOW"
// "IS SCRAPED"
// "IS SLASHED"
// "IS BATTERED"
fB7B1   .BYTE $0D,$18,$0D,$10,$0E,$1C,$24,$1D
        .BYTE $11,$0E,$24,$0B,$15,$18,$20,$12
        .BYTE $1C,$24,$1C,$0C,$1B,$0A,$19,$0E
        .BYTE $0D,$FF,$12,$1C,$24,$1C,$15,$0A
        .BYTE $1C,$11,$0E,$0D,$FF,$12,$1C,$24
        .BYTE $0B,$0A,$1D,$1D,$0E,$1B,$0E,$0D
        .BYTE $FF
		
// "DELETE CHARACTER 1-3 (0:NONE) "
fB7E2   .BYTE $0D,$0E,$15,$0E,$1D,$0E,$24,$0C
        .BYTE $11,$0A,$1B,$0A,$0C,$1D,$0E,$1B
        .BYTE $24,$01,$49,$03,$24,$4A,$00,$2A
        .BYTE $17,$18,$17,$0E,$28,$24

// $B800 'Dragon' sprite upper-left		
		.BYTE $00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$20
        .BYTE $00,$00,$08,$00,$00,$02,$00,$00
        .BYTE $02,$80,$00,$00,$A0,$00,$00,$A0
        .BYTE $00,$00,$A0,$00,$00,$A0,$00,$00
        .BYTE $A0,$00,$00,$A0

// $B840 'Dragon' sprite upper-right				
		.BYTE $00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$04,$00,$00,$05
        .BYTE $74,$00,$05,$55,$D0,$05,$55,$54
        .BYTE $05,$55,$50,$05,$54,$00,$05,$60
        .BYTE $00,$05,$60,$00,$05,$60,$00,$15
        .BYTE $60,$00,$55,$68
		
// $B880 'Dragon' sprite lower-left
		.BYTE $00,$00,$00,$A0
        .BYTE $01,$00,$80,$15,$02,$81,$55,$02
        .BYTE $95,$55,$0A,$55,$55,$09,$55,$55
        .BYTE $05,$55,$55,$05,$55,$55,$05,$55
        .BYTE $55,$15,$55,$55,$15,$55,$55,$15
        .BYTE $55,$55,$25,$55,$55,$25,$55,$55
        .BYTE $29,$65,$56,$29,$65,$6A,$09,$66
        .BYTE $AA,$01,$6A,$AA,$05,$00,$00,$15
        .BYTE $40,$00,$00,$00

// $B8C0 'Dragon' sprite lower-right 	
		.BYTE $01,$00,$55,$A8
        .BYTE $00,$55,$A8,$00,$55,$AA,$00,$55
        .BYTE $AA,$00,$55,$AA,$80,$55,$AA,$80
        .BYTE $55,$AA,$80,$55,$AA,$80,$55,$AA
        .BYTE $80,$55,$AA,$80,$55,$AA,$00,$55
        .BYTE $AA,$00,$55,$A9,$00,$95,$A9,$00
        .BYTE $95,$95,$00,$95,$15,$00,$95,$15
        .BYTE $00,$15,$15,$00,$14,$05,$00,$55
        .BYTE $15,$40,$55,$15
		
// $B900 'Ogre' sprite upper-left
		.BYTE $50,$00,$00,$00
        .BYTE $04,$20,$00,$01,$20,$00,$06,$A8
        .BYTE $00,$0B,$10,$00,$0A,$10,$00,$03
        .BYTE $10,$00,$02,$10,$00,$03,$10,$0D
        .BYTE $5F,$10,$3D,$55,$10,$3D,$55,$10
        .BYTE $3D,$55,$10,$3D,$55,$10,$3D,$55
        .BYTE $10,$3D,$55,$10,$3C,$55,$10,$FC
        .BYTE $55,$13,$FC,$55,$1F,$F0,$15,$AF
        .BYTE $C0,$15,$AC,$00

// $B940 'Ogre' sprite upper-right	
		.BYTE $15,$00,$04,$00
        .BYTE $00,$50,$00,$00,$64,$00,$00,$B8
        .BYTE $00,$00,$A8,$00,$00,$F0,$00,$00
        .BYTE $A0,$00,$00,$F0,$00,$00,$FD,$5C
        .BYTE $00,$55,$5F,$00,$55,$5F,$C0,$55
        .BYTE $5F,$F0,$55,$53,$FC,$55,$50,$FC
        .BYTE $55,$50,$FC,$55,$43,$F0,$55,$4F
        .BYTE $C0,$55,$6F,$00,$55,$AC,$00,$55
        .BYTE $80,$00,$55,$A0
		
// $B980 'Balrog' sprite upper-left
		.BYTE $00,$00,$00,$00
        .BYTE $00,$00,$01,$00,$00,$00,$40,$00
        .BYTE $00,$11,$00,$00,$05,$00,$00,$07
        .BYTE $0A,$00,$05,$08,$00,$01,$0A,$00
        .BYTE $03,$28,$00,$01,$2C,$00,$02,$2C
        .BYTE $0F,$EA,$3C,$3F,$FA,$3C,$FF,$FF
        .BYTE $3C,$FD,$FF,$3F,$FD,$7F,$3F,$F0
        .BYTE $55,$0F,$00,$55,$00,$00,$55,$00
        .BYTE $00,$15,$00,$00
		
// $B9C0 'Balrog' sprite upper-right
		.BYTE $15,$00,$00,$00
        .BYTE $00,$00,$10,$00,$00,$40,$00,$51
        .BYTE $00,$00,$54,$00,$00,$74,$00,$08
        .BYTE $54,$00,$08,$90,$00,$08,$F0,$00
        .BYTE $28,$50,$00,$0A,$A0,$00,$0E,$AA
        .BYTE $FC,$0E,$AB,$FF,$0F,$FF,$FF,$0F
        .BYTE $FF,$DF,$CF,$FF,$5F,$CF,$55,$43
        .BYTE $FF,$55,$40,$FC,$55,$40,$00,$55
        .BYTE $00,$00,$55,$00
	
// $BA00 Triggers messages (upstairs, downstairs, clues)
// " THERE ARE STAIRS  HERE, GOING UP.   TAKE THEM (Y-N)?"
// " THERE ARE STAIRS  HERE, GOING DOWN. TAKE THEM (Y-N)?"
// " A VOICE SAYS:     I HAVE LAID 3     CLUES TO BRING    YOU TO ME..."
// " A CLUE...         I AM DESTINY      PERSONIFIED"
// " A CLUE...         MY NAME IS IN     THE LOWER 4 MAPS"
// " A VOICE SAYS:     TOWARD THE NE     WARE THE STOP     ELSE MAGIC TRIES  TO MAKE YOU DROP "
// " A VOICE SAYS:     ANSWER THIS       RIDDLE TO PASS--   I LIE AHEAD       FOR EVERY MAN     THAT IS WITHIN    THE MASTER PLAN    I AM "
		.BYTE $00,$00,$24,$1D
        .BYTE $11,$0E,$1B,$0E,$24,$0A,$1B,$0E
        .BYTE $24,$1C,$1D,$0A,$12,$1B,$1C,$24
        .BYTE $24,$11,$0E,$1B,$0E,$25,$24,$10
        .BYTE $18,$12,$17,$10,$24,$1E,$19,$26
        .BYTE $24,$24,$24,$1D,$0A,$14,$0E,$24
        .BYTE $1D,$11,$0E,$16,$24,$4A,$22,$49
        .BYTE $17,$28,$27,$FF,$24,$1D,$11,$0E
        .BYTE $1B,$0E,$24,$0A,$1B,$0E,$24,$1C
        .BYTE $1D,$0A,$12,$1B,$1C,$24,$24,$11
        .BYTE $0E,$1B,$0E,$25,$24,$10,$18,$12
        .BYTE $17,$10,$24,$0D,$18,$20,$17,$26
        .BYTE $24,$1D,$0A,$14,$0E,$24,$1D,$11
        .BYTE $0E,$16,$24,$4A,$22,$49,$17,$28
        .BYTE $27,$FF,$24,$0A,$24,$1F,$18,$12
        .BYTE $0C,$0E,$24,$1C,$0A,$22,$1C,$2A
        .BYTE $24,$24,$24,$24,$24,$12,$24,$11
        .BYTE $0A,$1F,$0E,$24,$15,$0A,$12,$0D
        .BYTE $24,$03,$24,$24,$24,$24,$24,$0C
        .BYTE $15,$1E,$0E,$1C,$24,$1D,$18,$24
        .BYTE $0B,$1B,$12,$17,$10,$24,$24,$24
        .BYTE $24,$22,$18,$1E,$24,$1D,$18,$24
        .BYTE $16,$0E,$26,$26,$26,$FF,$24,$0A
        .BYTE $24,$0C,$15,$1E,$0E,$26,$26,$26
        .BYTE $24,$24,$24,$24,$24,$24,$24,$24
        .BYTE $24,$12,$24,$0A,$16,$24,$0D,$0E
        .BYTE $1C,$1D,$12,$17,$22,$24,$24,$24
        .BYTE $24,$24,$24,$19,$0E,$1B,$1C,$18
        .BYTE $17,$12,$0F,$12,$0E,$0D,$FF,$24
        .BYTE $0A,$24,$0C,$15,$1E,$0E,$26,$26
        .BYTE $26,$24,$24,$24,$24,$24,$24,$24
        .BYTE $24,$24,$16,$22,$24,$17,$0A,$16
        .BYTE $0E,$24,$12,$1C,$24,$12,$17,$24
        .BYTE $24,$24,$24,$24,$1D,$11,$0E,$24
        .BYTE $15,$18,$20,$0E,$1B,$24,$04,$24
        .BYTE $16,$0A,$19,$1C,$FF,$24,$0A,$24
        .BYTE $1F,$18,$12,$0C,$0E,$24,$1C,$0A
        .BYTE $22,$1C,$2A,$24,$24,$24,$24,$24
        .BYTE $1D,$18,$20,$0A,$1B,$0D,$24,$1D
        .BYTE $11,$0E,$24,$17,$0E,$24,$24,$24
        .BYTE $24,$24,$20,$0A,$1B,$0E,$24,$1D
        .BYTE $11,$0E,$24,$1C,$1D,$18,$19,$24
        .BYTE $24,$24,$24,$24,$0E,$15,$1C,$0E
        .BYTE $24,$16,$0A,$10,$12,$0C,$24,$1D
        .BYTE $1B,$12,$0E,$1C,$24,$24,$1D,$18
        .BYTE $24,$16,$0A,$14,$0E,$24,$22,$18
        .BYTE $1E,$24,$0D,$1B,$18,$19,$24,$FF
        .BYTE $24,$0A,$24,$1F,$18,$12,$0C,$0E
        .BYTE $24,$1C,$0A,$22,$1C,$2A,$24,$24
        .BYTE $24,$24,$24,$0A,$17,$1C,$20,$0E
        .BYTE $1B,$24,$1D,$11,$12,$1C,$24,$24
        .BYTE $24,$24,$24,$24,$24,$1B,$12,$0D
        .BYTE $0D,$15,$0E,$24,$1D,$18,$24,$19
        .BYTE $0A,$1C,$1C,$49,$49,$24,$24,$24
        .BYTE $12,$24,$15,$12,$0E,$24,$0A,$11
        .BYTE $0E,$0A,$0D,$24,$24,$24,$24,$24
        .BYTE $24,$24,$0F,$18,$1B,$24,$0E,$1F
        .BYTE $0E,$1B,$22,$24,$16,$0A,$17,$24
        .BYTE $24,$24,$24,$24,$1D,$11,$0A,$1D
        .BYTE $24,$12,$1C,$24,$20,$12,$1D,$11
        .BYTE $12,$17,$24,$24,$24,$24,$1D,$11
        .BYTE $0E,$24,$16,$0A,$1C,$1D,$0E,$1B
        .BYTE $24,$19,$15,$0A,$17,$24,$24,$24
        .BYTE $24,$12,$24,$0A,$16,$24,$FF

// $BBF9 (padding bytes ?)		
		.BYTE $00
        .BYTE $00,$00,$00,$00,$00,$00
		
// "(F)IGHT OR (R)UN"
fBC00   .BYTE $4A,$0F,$28,$12,$10,$11,$1D,$24
        .BYTE $18,$1B,$24,$4A,$1B,$28,$1E,$17
		
// "(W)EAP OR (S)PEL"	
fBC10   .BYTE $4A,$20,$28,$0E,$0A,$19,$24,$18
        .BYTE $1B,$24,$4A,$1C,$28,$19,$0E,$15

// "YOU GOT AWAY..."
fBC20   .BYTE $22,$18,$1E,$24,$10,$18,$1D,$24
        .BYTE $0A,$20,$0A,$22,$26,$26,$26

// "THEY CAUGHT YOU"		
fBC2F   .BYTE $1D,$11,$0E,$22,$24,$0C,$0A,$1E
        .BYTE $10,$11,$1D,$24,$22,$18,$1E
		
// "CASTS A SPELL..."
fBC3E   .BYTE $0C,$0A,$1C,$1D,$1C,$24,$0A,$24
        .BYTE $1C,$19,$0E,$15,$15,$26,$26,$26
		
// "HITS FOR "
// " PTS"
fBC4E   .BYTE $11,$12,$1D,$1C,$24,$0F,$18,$1B
        .BYTE $24,$24,$19,$1D,$1C
		
// "KILLED ONE"
fBC5B   .BYTE $14,$12,$15,$15,$0E,$0D,$24,$18
        .BYTE $17,$0E
		
// "IS MISSED"
fBC65   .BYTE $12,$1C,$24,$16,$12,$1C,$1C,$0E
        .BYTE $0D

// "TAKES "
// " DAMAGE"		
fBC6E   .BYTE $1D,$0A,$14,$0E,$1C,$24,$24,$0D
        .BYTE $0A,$16,$0A,$10,$0E
		
// "AND IS KILLED"
fBC7B   .BYTE $0A,$17,$0D,$24,$12,$1C,$24,$14
        .BYTE $12,$15,$15,$0E,$0D
		
// "SPELL NUMBER: "
fBC88   .BYTE $1C,$19,$0E,$15,$15,$24,$17,$1E
        .BYTE $16,$0B,$0E,$1B,$2A,$24
		
// "YOU ARE "
// " SPACES"
// "NORTH, "
// " SPACES"
// "EAST, "
// "AND LEVELS BELOW THE"
// "ENTRY STAIRS,"
// "NOW FACING "
fBC96   .BYTE $22,$18,$1E,$24,$0A,$1B,$0E,$24
        .BYTE $24,$1C,$19,$0A,$0C,$0E,$1C,$17
        .BYTE $18,$1B,$1D,$11,$25,$24,$24,$1C
        .BYTE $19,$0A,$0C,$0E,$1C,$0E,$0A,$1C
        .BYTE $1D,$25,$24,$0A,$17,$0D,$24,$15
        .BYTE $0E,$1F,$0E,$15,$1C,$24,$0B,$0E
        .BYTE $15,$18,$20,$24,$1D,$11,$0E,$0E
        .BYTE $17,$1D,$1B,$22,$24,$1C,$1D,$0A
        .BYTE $12,$1B,$1C,$25,$17,$18,$20,$24
        .BYTE $0F,$0A,$0C,$12,$17,$10,$24

// "NORTH"
// "EAST "
// "SOUTH"
// "WEST "		
fBCE5   .BYTE $17,$18,$1B,$1D,$11,$0E,$0A,$1C
        .BYTE $1D,$24,$1C,$18,$1E,$1D,$11,$20
        .BYTE $0E,$1C,$1D,$24
		
// "TELEPORT..."
// "LEVELS DOWN: "
// "NORTH: "
// "EAST: "
fBCF9   .BYTE $1D,$0E,$15,$0E,$19,$18,$1B,$1D
        .BYTE $26,$26,$26,$15,$0E,$1F,$0E,$15
        .BYTE $1C,$24,$0D,$18,$20,$17,$2A,$24
        .BYTE $17,$18,$1B,$1D,$11,$2A,$24,$0E
        .BYTE $0A,$1C,$1D,$2A,$24
	
// $BD1E (?? padding)
		.BYTE $85,$FF
		
// $BD20 40 custom chars 
// (' ','.',',','?',...) and MAZE MASTER logo
		.BYTE $00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$30,$30,$60,$00,$00
        .BYTE $00,$00,$00,$00,$60,$60,$00,$3C
        .BYTE $66,$06,$0C,$18,$00,$18,$00,$30
        .BYTE $18,$0C,$0C,$0C,$18,$30,$00,$00
        .BYTE $00,$00,$FF,$FF,$00,$00,$00,$00
        .BYTE $18,$18,$00,$18,$18,$00,$00,$18
        .BYTE $18,$18,$18,$18,$18,$18,$18,$00
        .BYTE $00,$00,$07,$0F,$1C,$18,$18,$00
        .BYTE $00,$00,$E0,$F0,$38,$18,$18,$18
        .BYTE $18,$1C,$0F,$07,$00,$00,$00,$18
        .BYTE $18,$38,$F0,$E0,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$E0,$60,$00
        .BYTE $00,$00,$00,$00,$00,$07,$06,$60
        .BYTE $78,$6C,$67,$61,$00,$01,$03,$06
        .BYTE $1E,$36,$E6,$86,$00,$80,$C0,$03
        .BYTE $0E,$18,$1F,$18,$00,$07,$1C,$C0
        .BYTE $70,$18,$F8,$18,$00,$E0,$38,$3F
        .BYTE $00,$03,$1E,$3F,$00,$3F,$31,$FC
        .BYTE $78,$C0,$00,$FC,$00,$FC,$8C,$3F
        .BYTE $30,$3F,$30,$3F,$00,$3F,$18,$FC
        .BYTE $00,$80,$00,$FC,$00,$FC,$0C,$00
        .BYTE $00,$00,$00,$00,$00,$7F,$30,$00
        .BYTE $00,$00,$00,$00,$00,$E0,$70,$70
        .BYTE $78,$7C,$6E,$67,$63,$E1,$00,$0E
        .BYTE $1E,$3E,$76,$E6,$C6,$87,$00,$07
        .BYTE $0E,$1C,$18,$1F,$18,$38,$00,$E0
        .BYTE $70,$38,$18,$F8,$18,$1C,$00,$38
        .BYTE $1C,$07,$00,$30,$1C,$07,$00,$0C
        .BYTE $00,$E0,$38,$1C,$38,$E0,$00,$01
        .BYTE $01,$01,$01,$01,$01,$03,$00,$80
        .BYTE $80,$80,$80,$80,$80,$C0,$00,$18
        .BYTE $19,$1F,$19,$18,$18,$3F,$00,$00
        .BYTE $80,$80,$80,$00,$0C,$FC,$00,$30
        .BYTE $30,$3F,$33,$31,$30,$70,$00,$38
        .BYTE $70,$E0,$80,$C0,$E0,$38,$00,$FF
        .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$00
        .BYTE $00,$00,$3C,$00,$00,$00,$00,$0C
        .BYTE $18,$30,$30,$30,$18,$0C,$00,$00
        .BYTE $18,$18,$7E,$18,$18,$00,$00
		
// Monsters data in group of 4 bytes
// first byte is multi-color 0
// second byte is multi-color 0
// third byte is the MSB of monster TOP sprite (LSB is $00)
// fourth byte is the MSB of monster BOTTOM sprite (LSB is $80)
fBE60   .BYTE $02
fBE61   .BYTE $05
fBE62   .BYTE $B9
fBE63   .BYTE $B5,$05,$0D,$B6,$B5,$0D,$05,$B6
        .BYTE $B5,$02,$05,$B4,$B5,$02,$0A,$B6
        .BYTE $B5,$06,$0A,$B9,$B5,$02,$0E,$B9
        .BYTE $B5,$02,$0E,$B5,$B5,$02,$08,$B9
        .BYTE $B5,$06,$0A,$B5,$B5,$02,$0E,$B4
        .BYTE $B5,$04,$09,$B9,$B5,$00,$08,$B7
        .BYTE $B5,$0C,$02,$B6,$B5,$02,$0A,$B7
        .BYTE $B5,$05,$06,$B9,$B5,$09,$0A,$B7
        .BYTE $B5,$0A,$09,$B7,$B5,$0A,$06,$09
        .BYTE $B5,$0E,$06,$B9,$B5,$0C,$0D,$06
        .BYTE $B5,$02,$0E,$B8,$B8,$0C,$0D,$B5
        .BYTE $B5,$0D,$05,$09,$B5,$08,$02,$B4
        .BYTE $B5,$05,$0A,$B8,$B8,$0A,$02,$06
        .BYTE $B5,$05,$0E,$B7,$B5,$02,$0A,$B9
        .BYTE $B5,$0C,$0D,$09,$B5,$08,$00,$B7
        .BYTE $B5,$0C,$0A,$B8,$B8,$0E,$06,$06
        .BYTE $B5,$08,$02,$B5,$B5,$0A,$0C,$B7
        .BYTE $B5,$00,$05,$B9,$B5,$0C,$0D,$B7
        .BYTE $B5,$04,$0C,$06,$B5,$0E,$05,$B8
        .BYTE $B8,$02,$08,$09,$B5


// ""
// "SWORD"
// "MAGIC SWORD"
// "RUNE-MACE"
// "WRATHBLADE"
// "LEATHER"
// "CHAIN MAIL"
// "MAGIC ARMOR"
// "MITHRIL COAT"
// "SHIELD"
// "MAGIC SHIELD"
// "WARDSHIELD"
// "DEFLECTOR"
// "STAFF OF LIGHT"
// "RING OF ACCURACY"
// "AMULET OF HEALING"
// "HAWK BLAZON"
fBF00   .BYTE $FF,$1C,$20,$18,$1B,$0D,$FF,$16
        .BYTE $0A,$10,$12,$0C,$24,$1C,$20,$18
        .BYTE $1B,$0D,$FF,$1B,$1E,$17,$0E,$49
        .BYTE $16,$0A,$0C,$0E,$FF,$20,$1B,$0A
        .BYTE $1D,$11,$0B,$15,$0A,$0D,$0E,$FF
        .BYTE $15,$0E,$0A,$1D,$11,$0E,$1B,$FF
        .BYTE $0C,$11,$0A,$12,$17,$24,$16,$0A
        .BYTE $12,$15,$FF,$16,$0A,$10,$12,$0C
        .BYTE $24,$0A,$1B,$16,$18,$1B,$FF,$16
        .BYTE $12,$1D,$11,$1B,$12,$15,$24,$0C
        .BYTE $18,$0A,$1D,$FF,$1C,$11,$12,$0E
        .BYTE $15,$0D,$FF,$16,$0A,$10,$12,$0C
        .BYTE $24,$1C,$11,$12,$0E,$15,$0D,$FF
        .BYTE $20,$0A,$1B,$0D,$1C,$11,$12,$0E
        .BYTE $15,$0D,$FF,$0D,$0E,$0F,$15,$0E
        .BYTE $0C,$1D,$18,$1B,$FF,$1C,$1D,$0A
        .BYTE $0F,$0F,$24,$18,$0F,$24,$15,$12
        .BYTE $10,$11,$1D,$FF,$1B,$12,$17,$10
        .BYTE $24,$18,$0F,$24,$0A,$0C,$0C,$1E
        .BYTE $1B,$0A,$0C,$22,$FF,$0A,$16,$1E
        .BYTE $15,$0E,$1D,$24,$18,$0F,$24,$11
        .BYTE $0E,$0A,$15,$12,$17,$10,$FF,$11
        .BYTE $0A,$20,$14,$24,$0B,$15,$0A,$23
        .BYTE $18,$17,$FF
		
// (padding bytes ?)
		.BYTE $00,$00,$00,$00,$14
		
// Items prices by pair of bytes (LSB and MSB)
// SWORD = 20
// MAGIC SWORD = 500
// RUNE-MACE = 1500
// WRATHBLADE = 4000
//
// LEATHER = 50
// CHAIN MAIL = 100
// MAGIC ARMOR = 2000
// MITHRIL COAT = 6000
//
// SHIELD = 35
// MAGIC SHIELD = 200
// WARDSHIELD = 800
// DEFLECTOR = 1500
//
// STAFF OF LIGHT = 5000
// RING OF ACCURACY = 1500
// AMULET OF HEALING = 5000
// HAWK BLAZON = 10000
fBFC0   .BYTE $14
fBFC1   .BYTE $00,$F4,$01,$DC,$05,$A0,$0F,$32
        .BYTE $00,$64,$00,$D0,$07,$70,$17,$23
        .BYTE $00,$C8,$00,$20,$03,$DC,$05,$88
        .BYTE $13,$DC,$05,$88,$13,$10,$27
		
// $BFE0 (cartridge checksum and sign ?)
		.BYTE $00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$4E,$30,$3A,$44,$45,$46,$45
        .BYTE $4E,$44,$45,$52,$56,$31,$2E,$35
        .BYTE $2C,$49,$0D,$0D,$49,$42,$0D
